#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
#define infinity = 1. / 0.

layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

/* STRUCTS */

struct Ray{
	dvec3 position;
	double weight; // status of the ray (e.g if element missed -> 0)
	dvec4 direction;
};
struct Quadric{
	dmat4 anchorPoints;
	dmat4 inTrans;
	dmat4 outTrans;
	dmat4 misalignment;
	dmat4 inverseMisalignment;
};
layout(std140, binding = 0) buffer ibuf
{
   Ray rayData[];
};

layout(std140, binding = 1) buffer obuf
{
   Ray outputData[];
};
layout(std140, binding = 2) buffer qbuf
{
	double numberOfBeamlines;
	double numberOfQuadricsPerBeamline;
	double numberOfRays;
	double numberOfRaysPerBeamLine;
	Quadric quadricData[];
};
layout(std140, binding = 3) buffer xyzbuf
{
	dvec4 xyznull[];
};


// TRIGONOMETRIC FUNCTIONS USING MINIMAX APPROXIMATION

// OLD: (not double):

/**
* sin approximation
* error < 2e-11
* source: https://outerra.blogspot.com/2017/06/fp64-approximations-for-sincos-for.html
*/
double sina_11(double x)
{
    //minimax coefs for sin for 0..pi/2 range
    const double a3 = -1.666666660646699151540776973346659104119e-1LF;
    const double a5 =  8.333330495671426021718370503012583606364e-3LF;
    const double a7 = -1.984080403919620610590106573736892971297e-4LF;
    const double a9 =  2.752261885409148183683678902130857814965e-6LF;
    const double ab = -2.384669400943475552559273983214582409441e-8LF;

    const double m_2_pi = 0.636619772367581343076LF;
    const double m_pi_2 = 1.57079632679489661923LF;

    double y = abs(x * m_2_pi);
    double q = floor(y);
    int quadrant = int(q);

    double t = (quadrant & 1) != 0 ? 1 - y + q : y - q;
    t *= m_pi_2;

    double t2 = t * t;
    double r = fma(fma(fma(fma(fma(ab, t2, a9), t2, a7), t2, a5), t2, a3),
        t2*t, t);

    r = x < 0 ? -r : r;

    return (quadrant & 2) != 0 ? -r : r;
}

/** cos approximation, error < 2e-11
* uses sina_11 with shifted input (+pi/2)
*/
double cosa_11(double x)
{
    //sin(x + PI/2) = cos(x)
    return sina_11(x + 1.57079632679489661923LF);
}

/**
* atan2 approximation
* error < 5e-9
* source: 
* https://outerra.blogspot.com/2014/05/double-precision-approximations-for-map.html
*/
double arctan2(double y, double x)
{
    const double atan_tbl[] = {
    -3.333333333333333333333333333303396520128e-1LF,
     1.999999117496509842004185053319506031014e-1LF,
    -1.428514132711481940637283859690014415584e-1LF,
     1.110012236849539584126568416131750076191e-1LF,
    -8.993611617787817334566922323958104463948e-2LF,
     7.212338962134411520637759523226823838487e-2LF,
    -5.205055255952184339031830383744136009889e-2LF,
     2.938542391751121307313459297120064977888e-2LF,
    -1.079891788348568421355096111489189625479e-2LF,
     1.858552116405489677124095112269935093498e-3LF
    };

    /* argument reduction: 
       arctan (-x) = -arctan(x); 
       arctan (1/x) = 1/2 * pi - arctan (x), when x > 0
    */

    double ax = abs(x);
    double ay = abs(y);
    double t0 = max(ax, ay);
    double t1 = min(ax, ay);
    
    double a = 1 / t0;
    a *= t1;

    double s = a * a;
    double p = atan_tbl[9];

    p = fma( fma( fma( fma( fma( fma( fma( fma( fma( fma(p, s,
        atan_tbl[8]), s,
        atan_tbl[7]), s, 
        atan_tbl[6]), s,
        atan_tbl[5]), s,
        atan_tbl[4]), s,
        atan_tbl[3]), s,
        atan_tbl[2]), s,
        atan_tbl[1]), s,
        atan_tbl[0]), s*a, a);

    double r = ay > ax ? (1.57079632679489661923LF - p) : p;

    r = x < 0 ?  3.14159265358979323846LF - r : r;
    r = y < 0 ? -r : r;

    return r;
}

/**
* DOUBLE PRECISION APPROXIMATION FOR ARCTAN AND COSINUS
* source: https://people.sc.fsu.edu/~jburkardt/c_src/fn/fn.html
*/

int r8_inits ( double dos[16], int nos, double eta )

/******************************************************************************/
/*
  Purpose:

    R8_INITS initializes a Chebyshev series.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    22 April 2016

  Author:

    C version by John Burkardt.

  Reference:

    Roger Broucke,
    Algorithm 446:
    Ten Subroutines for the Manipulation of Chebyshev Series,
    Communications of the ACM,
    Volume 16, Number 4, April 1973, pages 254-256.

  Parameters:

    Input, double DOS[NOS], the Chebyshev coefficients.

    Input, int NOS, the number of coefficients.

    Input, double ETA, the desired accuracy.

    Output, int R8_INITS, the number of terms of the series needed
    to ensure the requested accuracy.
*/
{
	double err;
	int i;
	int value;

  	if ( nos < 1 ){
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_INITS - Fatal error!\n" );
		//fprintf ( stderr, "  Number of coefficients < 1.\n" );
		return 1;
  	}

  	if ( eta < dos[nos-1] ){
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_INITS - Warning!\n" );
		//fprintf ( stderr, "  ETA may be too small.\n" );
		//fprintf ( stderr, "  The requested accuracy cannot be guaranteed.\n" );
		//fprintf ( stderr, "  even if all available coefficients are used.\n" );
		value = nos;
  	}else{
    	err = 0.0;
 
    	for ( i = nos - 1; 0 <= i; i-- ){
      		value = i + 1;
      		err = err + abs ( dos[i] );
      		if ( eta < err ){
        		break;
      		}
    	}
	}

	return value;
}

double r8_mach ( int i )

/******************************************************************************/
/*
  Purpose:

    R8_MACH returns double precision real machine constants.

  Discussion:

    Assuming that the internal representation of a double precision real
    number is in base B, with T the number of base-B digits in the mantissa,
    and EMIN the smallest possible exponent and EMAX the largest possible 
    exponent, then

      R8_MACH(1) = B^(EMIN-1), the smallest positive magnitude.
      R8_MACH(2) = B^EMAX*(1-B^(-T)), the largest magnitude.
      R8_MACH(3) = B^(-T), the smallest relative spacing.
      R8_MACH(4) = B^(1-T), the largest relative spacing.
      R8_MACH(5) = log10(B).

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    24 April 2007

  Author:

    Original FORTRAN77 version by Phyllis Fox, Andrew Hall, Norman Schryer.
    C version by John Burkardt.

  Reference:

    Phyllis Fox, Andrew Hall, Norman Schryer,
    Algorithm 528:
    Framework for a Portable Library,
    ACM Transactions on Mathematical Software,
    Volume 4, Number 2, June 1978, page 176-188.

  Parameters:

    Input, int I, chooses the parameter to be returned.
    1 <= I <= 5.

    Output, double R8_MACH, the value of the chosen parameter.
*/
{
  	double value;

  	if ( i < 1 ) {
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_MACH - Fatal error!\n" );
		//fprintf ( stderr, "  The input argument I is out of bounds.\n" );
		//fprintf ( stderr, "  Legal values satisfy 1 <= I <= 5.\n" );
		//fprintf ( stderr, "  I = %d\n", i );
    	value = 0.0;
    	return value;
  	}else if ( i == 1 ) {
    	value = 4.450147717014403E-308;
  	}else if ( i == 2 ){
    	value = 8.988465674311579E+307;
	}else if ( i == 3 ){
    	value = 1.110223024625157E-016;
  	}else if ( i == 4 ) {
    	value = 2.220446049250313E-016;
	}else if ( i == 5 ) {
    	value = 0.301029995663981E+000;
  	}else if ( 5 < i ) {
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_MACH - Fatal error!\n" );
		//fprintf ( stderr, "  The input argument I is out of bounds.\n" );
		//fprintf ( stderr, "  Legal values satisfy 1 <= I <= 5.\n" );
		//fprintf ( stderr, "  I = %d\n", i );
		value = 0.0;
	}
	return value;
}

double r8_csevl ( double x, double a[16], int n )

/******************************************************************************/
/*
  Purpose:

    R8_CSEVL evaluates a Chebyshev series.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    17 January 2012

  Author:

    C version by John Burkardt.

  Reference:

    Roger Broucke,
    Algorithm 446:
    Ten Subroutines for the Manipulation of Chebyshev Series,
    Communications of the ACM,
    Volume 16, Number 4, April 1973, pages 254-256.

  Parameters:

    Input, double X, the evaluation point.

    Input, double CS[N], the Chebyshev coefficients.

    Input, int N, the number of Chebyshev coefficients.

    Output, double R8_CSEVL, the Chebyshev series evaluated at X.
*/
{
	double b0;
	double b1;
	double b2;
	int i;
	double twox;
	double value;

  	if ( n < 1 ) {
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_CSEVL - Fatal error!\n" );
		//fprintf ( stderr, "  Number of terms <= 0.\n" );
		return 1;
  	}

  	if ( 1000 < n ) {
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_CSEVL - Fatal error!\n" );
		//fprintf ( stderr, "  Number of terms greater than 1000.\n" );
		return 1;
 	}

  	if ( x < -1.1 || 1.1 < x ) {
		//fprintf ( stderr, "\n" );
		//fprintf ( stderr, "R8_CSEVL - Fatal error!\n" );
		//fprintf ( stderr, "  X outside (-1,+1).\n" );
		return 1;
  	}

	twox = 2.0 * x;
	b1 = 0.0;
	b0 = 0.0;

  	for ( i = n - 1; 0 <= i; i-- ){
		b2 = b1;
		b1 = b0;
		b0 = twox * b1 - b2 + a[i];
  	}

  	value = 0.5 * ( b0 - b2 );
	return value;
}

double r8_cos ( double x )

/******************************************************************************/
/*
  Purpose:

    R8_COS evaluates the cosine of an R8 argument.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    17 January 2012

  Author:

    Original FORTRAN77 version by Wayne Fullerton.
    C version by John Burkardt.

  Reference:

    Wayne Fullerton,
    Portable Special Function Routines,
    in Portability of Numerical Software,
    edited by Wayne Cowell,
    Lecture Notes in Computer Science, Volume 57,
    Springer 1977,
    ISBN: 978-3-540-08446-4,
    LC: QA297.W65.

  Parameters:

    Input, double X, the argument.

    Output, double R8_COS, the cosine of X.
*/
{
  double absx;
  double f;
  int n2;
  int ntsn = 0;
  const double pi2 = 1.57079632679489661923132169163975;
  const double pi2rec = 0.63661977236758134307553505349006;
  const double pihi = 3.140625;
  const double pilo = 9.6765358979323846264338327950288E-04;
  const double pirec = 0.31830988618379067153776752674503;
  double sincs[16] = double[16](
   -0.374991154955873175839919279977323464,
   -0.181603155237250201863830316158004754,
    0.005804709274598633559427341722857921,
   -0.000086954311779340757113212316353178,
    0.000000754370148088851481006839927030,
   -0.000000004267129665055961107126829906,
    0.000000000016980422945488168181824792,
   -0.000000000000050120578889961870929524,
    0.000000000000000114101026680010675628,
   -0.000000000000000000206437504424783134,
    0.000000000000000000000303969595918706,
   -0.000000000000000000000000371357734157,
    0.000000000000000000000000000382486123,
   -0.000000000000000000000000000000336623,
    0.000000000000000000000000000000000256,0.1 );
  double value;
  double xmax = 0.0;
  double xn;
  double xsml = 0.0;
  double xwarn = 0.0;
  double y;
  
  if ( ntsn == 0 )
  {
    ntsn = r8_inits ( sincs, 15, 0.1 * r8_mach ( 3 ) );
    xsml = sqrt ( 2.0 * r8_mach ( 3 ) );
    xmax = 1.0 / r8_mach ( 4 );
    xwarn = sqrt ( xmax );
  }

  absx = abs ( x );
  y = absx + pi2;
  
  if ( xmax < y )
  {
    value = 0.5;
    return value;
  }

  

  value = 1.0;
  
  if ( absx < xsml )
  {
    return 0.5;
  }

  xn =  floor ( y * pirec + 0.5 ) ;
  n2 = int ( mod ( xn, 2.0 ) + 0.5 );
  xn = xn - 0.5;
  f = ( absx - xn * pihi ) - xn * pilo;

  xn = 2.0 * ( f * pi2rec ) * ( f * pi2rec ) - 1.0;
  value = f + f * r8_csevl ( xn, sincs, ntsn );

  if ( n2 != 0 )
  {
    value = - value;
  }

  if ( value < -1.0 )
  {
    value = -1.0;
  }
  else if ( 1.0 < value )
  {
    value = 1.0;
  }
  return value;
}

double r8_atan ( double x )

/******************************************************************************/
/*
  Purpose:

    R8_ATAN evaluates the arc-tangent of an R8 argument.

  Licensing:

    This code is distributed under the GNU LGPL license. 

  Modified:

    17 January 2012

  Author:

    Original FORTRAN77 version by Wayne Fullerton.
    C version by John Burkardt.

  Reference:

    Wayne Fullerton,
    Portable Special Function Routines,
    in Portability of Numerical Software,
    edited by Wayne Cowell,
    Lecture Notes in Computer Science, Volume 57,
    Springer 1977,
    ISBN: 978-3-540-08446-4,
    LC: QA297.W65.

  Parameters:

    Input, double X, the argument.

    Output, double R8_ATAN, the arc-tangent of X.
*/
{
	double atancs[16] = double[16](
		+0.48690110349241406474636915902891E+00,
		-0.65108316367174641818869794945974E-02,
		+0.38345828265245177653569992430456E-04,
		-0.26872212876223146539595410518788E-06,
		+0.20500930985824269846636514686688E-08,
		-0.16450717395484269455734135285348E-10,
		+0.13650975274390773423813528484428E-12,
		-0.11601779591998246322891309834666E-14,
		+0.10038333943866273835797657402666E-16,
		-0.88072747152163859327073696000000E-19,
		+0.78136321005661722180580266666666E-21,
		-0.69954535148267456086613333333333E-23,
		+0.63105905713702136004266666666666E-25,
		-0.57296075370213874346666666666666E-27,
		+0.52274796280602282666666666666666E-29,
		-0.48327903911608320000000000000000E-31 );
	const double conpi8[4] = double[4](0.375, 0.75, 1.125, 1.5);
	int n;
	int nterms = 0;
	const double pi8[4] = double[4](
		+0.17699081698724154807830422909937E-01,
		+0.35398163397448309615660845819875E-01,
		+0.53097245096172464423491268729813E-01,
		+0.70796326794896619231321691639751E-01 );
	double sqeps = 0.0;
	double t;
	const double tanp8[3] = double[3](
		+0.41421356237309504880168872420969,
		+1.0,
		+2.4142135623730950488016887242096 );
	double value;
	double xbig = 0.0;
	const double xbnd1 = +0.19891236737965800691159762264467;
	const double xbnd2 = +0.66817863791929891999775768652308;
	const double xbnd3 = +1.4966057626654890176011351349424;
	const double xbnd4 = +5.0273394921258481045149750710640;
	double y;

  	if ( nterms == 0 ) {
		nterms = r8_inits ( atancs, 16, 0.1 * r8_mach ( 3 ) );
		sqeps = sqrt ( 6.0 * r8_mach ( 3 ) );
		xbig = 1.0 / r8_mach ( 3 );
  	}

  	y = abs ( x );

  	if ( y <= xbnd1 ) {
    	value = x;
    	if ( sqeps < y ) {
     	 value = x * ( 0.75 + r8_csevl ( 50.0 * y * y - 1.0, atancs, nterms ) );
    	}
  	}else if ( y <= xbnd4 ) {
    	if ( xbnd3 < y ) {
      		n = 3;
    	}else if ( xbnd2 < y ) {
      		n = 2;
    	}else {
      		n = 1;
    	}
		t = ( y - tanp8[n-1] ) / ( 1.0 + y * tanp8[n-1] );
		value = conpi8[n-1] + ( pi8[n-1] + t * ( 0.75 + r8_csevl ( 50.0 * t * t - 1.0, atancs, nterms ) ) );
	}else {
		value = conpi8[3] + pi8[3];
		if ( y < xbig ) {
			value = conpi8[3] + ( pi8[3] - ( 0.75 + r8_csevl ( 50.0 / y / y - 1.0, atancs, nterms ) ) / y );
		}
  	}

  	if ( x < 0.0 ) {
  		value = - abs ( value );
  	}
  	else {
    	value = + abs ( value );
  	}
	return value;
}

// DERIVED FUNCTIONS FOR SIN AND ASIN:

double r8_sin ( double x ) {
	double pi_half = 1.570796326794896619231321691639751442;
	return r8_cos(pi_half - x);
}

double r8_asin ( double x ) {
	return sign(x) * r8_atan(sqrt( (x*x) / (1-x*x) ));
}










/* HERE STARTS RAY TRACING CODE */

/**
* uses given transformation matrix to transform ray position and direction into Object coordinates
* also takes misalignment of the object into account
* @param r				input ray in Ray-coordinates
* @param misaligment	4x4 homogeneous matrix that contains the misalignemnt of the element (dx, dy, dz, dphi, dpsi, dchi)
* @param inTrans		4x4 homogeneous matrix that contains the transformation of ray-coordinates to object coordinates (distance to previous element, grazing incidence angle, azimuthal angle)
* 
* output: nothing. changes r in situ
*/
void inTransformation(inout Ray r, dmat4 misalignment, dmat4 inTrans) {
	r.position = dvec3(misalignment * (inTrans *  dvec4(r.position,1)) );
	r.direction = dvec4(misalignment * (inTrans * r.direction));
}

/**
* uses given transformation matrix to transform ray position and direction back into Ray coordinates
* also takes misalignment of the object into account. Note that the order of the transformations is reversed and we use the inverse of the misalignment matrix
* @param r				input ray in Ray-coordinates
* @param invMisaligment	4x4 homogeneous matrix that contains the misalignemnt of the element (dx, dy, dz, dphi, dpsi, dchi)
* @param outTrans		3x3 homogeneous matrix (in 4x4 matrix for standardization) that contains the transformation of object coordinates to ray-coordinates (rotations only: grazing exit angle, neg. azimuthal angle)
* 
* output: nothing. changes r in situ
*/
void outTransformation(inout Ray r, dmat4 invMisalignment, dmat4 outTrans) {
	r.position = dvec3(outTrans * (invMisalignment * dvec4(r.position,1)));
	r.direction = outTrans * (invMisalignment * r.direction);
}

/**
* checks whether the intersection point is within the extent of the surface
* @param x, z			 	x- and z-coordinates of the intersection point
* @param xLength, zLength	width and length of the optical element
* @param w 					current weight of the ray
*
* returns: unchanged weight if intersection point is within surface boundaries, 0.0 if not.
*/
double wasteBox(double x, double z, double xLength, double zLength, double w) 
{
	double x_min = -xLength/2.0;
	double x_max = xLength/2.0;
	double z_min = -zLength/2.0;
	double z_max = zLength/2.0;

	if (xLength >= 0){ // Rectangular shape
		if (x <= x_min || x >= x_max || z <= z_min || z >= z_max) {
			return 0.0;
		}
	}else{	// Ring shape
		double rd2 = (x/(xLength/2.0)) * (x/(xLength/2.0)) + (z/(zLength/2.0))*(z/(zLength/2.0));
		if (rd2 > 1.0) {
			return 0.0;
		}
	} 
	return w;
}

/**
* calculates the intersection point of a ray with a quadric surface defined by a_11..a_44
* @param r				ray for which the intersection is fount
* @param a_11..a_44		define the quadric surface
* @param icurv 			defines whether the first or the second intersection is used (1=first, -1=second)
*
* output: reflected Ray with intersection point as position and reflection as direction
*/
dvec4 intersectionPoint(dmat4 inputQuadric, int icurv)
{	
	const dmat4 quadric = inputQuadric;
	Ray r = rayData[uint(gl_GlobalInvocationID)];
	double w = r.weight;
	int cs = 0;
	if (abs(r.direction[1]) >= abs(r.direction[0]) && abs(r.direction[1]) >= abs(r.direction[2])) {
		cs = 1;
	}else if (abs(r.direction[2]) >= abs(r.direction[0]) && abs(r.direction[2]) >= abs(r.direction[1])) {
		cs = 2;
	}
	uint f_001 = uint(cs/2);
	uint f_010 = cs%2;
	uint f_011 = uint(cs/cs);
	uint f_012 = cs;
	uint f_100 = (uint(cs/cs)+1)%2;
	uint f_101 = ((cs%2)+1)%2;
	uint f_110 = (uint(cs/2)+1)%2;
	uint f_112 = int(cs/2)+1;
	uint f_1x0 = (cs+1)%3;
	uint f_131 = ((cs%2)*2)+1;
	uint f_220 = (uint(cs/2)+2)%3;
	uint f_221 = ((uint(cs/2)+1)%2)+1;

    //Formula: ((x+1)%3)/(x-1) and (x%3)/(x-1)
	double firstParam = r.direction[f_100] / r.direction[cs];
	double secondParam = r.direction[f_221] / r.direction[cs];
	double params[2] = {firstParam, secondParam};
	//dvec4 normal;

	xyznull[uint(gl_GlobalInvocationID)][f_100] = r.position[f_100] - firstParam * r.position[cs];
	xyznull[uint(gl_GlobalInvocationID)][f_221] = r.position[f_221] - secondParam * r.position[cs];
	xyznull[uint(gl_GlobalInvocationID)][3] = 0;

	const int d_sign = int(sign(r.direction[cs]) * icurv);

	double a = quadric[cs][cs] + 2*quadric[0][f_112]*params[f_101] + quadric[f_100][f_100]*params[f_101]*params[f_101] + 2*quadric[f_011][2]*params[f_010] + quadric[f_100][f_221]*params[f_101]*params[f_101];
	double b = quadric[cs][3] + quadric[f_100][3]*params[f_001] + quadric[f_221][3]*params[f_110] + (quadric[0][f_112] + quadric[f_100][f_100]*params[f_001] + quadric[f_100][f_221]*params[f_110])*xyznull[uint(gl_GlobalInvocationID)][f_100] + (quadric[f_011][2] + quadric[f_100][f_221]*params[f_001] + quadric[f_221][f_221]*params[f_110])*xyznull[uint(gl_GlobalInvocationID)][f_221];
	double c = quadric[3][3] + quadric[f_100][f_100]*xyznull[uint(gl_GlobalInvocationID)][f_100]*xyznull[uint(gl_GlobalInvocationID)][f_100] + 2*quadric[f_221][3]*xyznull[uint(gl_GlobalInvocationID)][f_221] + quadric[f_221][f_221]*xyznull[uint(gl_GlobalInvocationID)][f_221]*xyznull[uint(gl_GlobalInvocationID)][f_220] + 2*xyznull[uint(gl_GlobalInvocationID)][f_100]*(quadric[f_100][3] +quadric[f_100][f_221]*xyznull[uint(gl_GlobalInvocationID)][f_221]);


	
	double bbac = b*b - a*c;
	if (bbac < 0) {
		w = -4;
		xyznull[uint(gl_GlobalInvocationID)][cs] = - xyznull[uint(gl_GlobalInvocationID)][f_131]/params[f_1x0]; 	// x such that y=0
	}
	else{
		if (abs(a) > abs(c)*1e-10) {
			xyznull[uint(gl_GlobalInvocationID)][cs] = (-b + d_sign*sqrt(bbac)) / a;
		}else{
			xyznull[uint(gl_GlobalInvocationID)][cs] = (-c/2)/b;
		}
	}
	xyznull[uint(gl_GlobalInvocationID)][f_100] = xyznull[uint(gl_GlobalInvocationID)][f_100] + firstParam * xyznull[uint(gl_GlobalInvocationID)][cs];
	xyznull[uint(gl_GlobalInvocationID)][f_221] = xyznull[uint(gl_GlobalInvocationID)][f_221] + secondParam*xyznull[uint(gl_GlobalInvocationID)][cs];
	
	
	const double fx = 2*quadric[0][3] + 2*quadric[0][0]*xyznull[uint(gl_GlobalInvocationID)][0] + 2*quadric[0][1]*xyznull[uint(gl_GlobalInvocationID)][1] + 2*quadric[0][2]*xyznull[uint(gl_GlobalInvocationID)][2];
	const double fy = 2*quadric[1][3] + 2*quadric[0][1]*xyznull[uint(gl_GlobalInvocationID)][0] + 2*quadric[1][1]*xyznull[uint(gl_GlobalInvocationID)][1] + 2*quadric[1][2]*xyznull[uint(gl_GlobalInvocationID)][2];
    const double fz = 2*quadric[2][3] + 2*quadric[0][2]*xyznull[uint(gl_GlobalInvocationID)][0] + 2*quadric[1][2]*xyznull[uint(gl_GlobalInvocationID)][1] + 2*quadric[2][2]*xyznull[uint(gl_GlobalInvocationID)][2];
	
	dvec4 normal = normalize(dvec4(fx,fy,fz,0));
	r.position = dvec3(xyznull[uint(gl_GlobalInvocationID)][0],xyznull[uint(gl_GlobalInvocationID)][1],xyznull[uint(gl_GlobalInvocationID)][2]); // new position = intersection point
	r.weight = w; // unchanged, if ray did not miss surface, else 0
	r.position = dvec3(9999999.9, 42678234.9, 326574683.9);
	return normal;
}

// refraction function used for gratings
Ray refrac(Ray r, dvec4 normal, double a){
	double xy = normal[0] / normal[1];
	double zy = normal[2] / normal[1];
	double sqq = sqrt(1 + zy*zy + xy*xy);
	double an_x = xy/sqq;
	double an_y = -1.0/sqq;
	double an_z = zy/sqq;

	double eps1 = r8_atan(an_x/ an_y); //-atan(an_x/an_z) around z, chi
	double del1 = r8_asin(an_z); // sign(an_z) * r8_atan(sqrt( (an_z*an_z) / (1-an_z*an_z) )); // -asin(an_z); // -asin around x, psi
	double cos_d = r8_cos(del1);
	double a1 = a*cos_d;
	double sin_d = r8_sin(-del1);
	double cos_e = r8_cos(-eps1);
	double sin_e = r8_sin(-eps1);
	dmat4 rot = dmat4(cos_e, cos_d*sin_e, sin_d*sin_e, 0,
				-sin_e, cos_d*cos_e, sin_d*cos_e, 0,
				0, -sin_d, cos_d, 0,
				0,0,0,1);
	dmat4 inv_rot = dmat4(cos_e, -sin_e, 0, 0, 
				cos_d*sin_e, cos_d*cos_e, -sin_d, 0,
				sin_d*sin_e, sin_d*cos_e, cos_d, 0,
				0,0,0,1);
	r.direction = dvec4(rot * r.direction);
	
	double y1 = (r.direction[1]*r.direction[1]+r.direction[2]*r.direction[2]-((r.direction[2]-a1)*(r.direction[2]-a1)));
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] -= a1;
	}else{
	   r.weight = 0.0;
	}
	r.direction = dvec4(inv_rot * r.direction);
	return r;
}

/* 
* simplified refraction function used for plane gratings
* normal is always the same (0,1,0) -> no rotation and thus no trigonometric functions necessary
* @param r			ray
* @param normal		normal at ray-object intersection (for planes always (0,1,0))
* @param a			a = WL * D0 * ORD * 1.e-6  with D0: line density (l/mm); WL:wavelength (nm); ORD order of diffraction
*/
Ray refrac_plane(Ray r, dvec4 normal, double a){
	double y1 = r.direction[1]*r.direction[1] + r.direction[2]*r.direction[2] - (r.direction[2]-a)*(r.direction[2]-a);
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] = r.direction[2] - a;
	}else{
	   r.weight = -4; // status?
	}
	return r;
}

/** 
* calculates resulting ray for plane grating element
* separate from "generalGratingElement" because normal is always (0,-1,0). Therefore, the refrac function can be simplified such that it does not use trigonom. functions
* transforms ray to object coordinate system, takes misalignment into account, traces the ray and transforms ray resulting of interaction with grating back to beam coordinates
* @param r				ray to trace
* @param q				quadric parameters of the grating (a_24=-1)
*
* output: reflected Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight
*/
Ray tracePlaneGrating(Ray r, Quadric q, dvec4 normal) {
	inTransformation(r, q.misalignment, q.inTrans);
	
	r = refrac_plane(r, normal, q.anchorPoints[2][1]); // 
	
	double xLength = q.anchorPoints[1][0]; // width; only 10 of the 16 anchorpoints are important for the intersection point function ("quad function"), since the matrix A is symmetric
	double zLength = q.anchorPoints[2][0]; // length; therefore we can use 6 values in the lower left part (without the diagonal) to transfer other values to the shader (eg dimensions of a mirror/grating), we use a_21,a_31 for xlength and zlength
	r.weight = wasteBox(r.position[0],r.position[2],xLength,zLength, r.weight);
	
	outTransformation(r, q.inverseMisalignment, q.outTrans);
	return r;
}

/** 
* calculates resulting ray for general grating element
* transforms ray to object coordinate system, takes misalignment into account, traces the ray and transforms ray resulting of interaction with grating back to beam coordinates
* @param r				ray to trace
* @param q				quadric surface
*
* output: reflected Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight
*/
Ray traceGeneralGrating(Ray r, Quadric q) {
	inTransformation(r, q.misalignment, q.inTrans);
	
	int ISIG = 1;
	if(-q.anchorPoints[1][3] < 0) {
		ISIG = -1;
	}
	dvec4 normal = intersectionPoint(q.anchorPoints, ISIG);
	normal = normalize(dvec4(-r.position[0], -q.anchorPoints[1][3] - r.position[1]*ISIG, -r.position[2], 0));
	r = refrac(r, normal, q.anchorPoints[2][1]);
	
	double xLength = q.anchorPoints[1][0]; // only 10 of the 16 anchorpoints are important for the intersection point function ("quad function"), since the matrix A is symmetric
	double zLength = q.anchorPoints[2][0]; // therefore we can use 6 values in the lower left part (without the diagonal) to transfer other values to the shader (eg dimensions of a mirror/grating), we use a_21,a_31 for xlength and zlength
	r.weight = wasteBox(r.position[0],r.position[2],xLength,zLength, r.weight);

	outTransformation(r, q.inverseMisalignment, q.outTrans);
	return r;
}

/**
* calculates resulting ray for a mirror element
* transforms ray to object coordinate system, takes misalignment into account, traces the ray and transforms ray resulting of interaction with opt. element back to beam coordinates
* @param r				ray to trace
* @param q				quadric surface
*
* output: reflected Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight
*/
Ray traceMirror(Ray r, Quadric q, dvec4 normal) {
	inTransformation(r, q.misalignment, q.inTrans);
	
	r.direction = reflect(r.direction, normal);
	
	// will be changed, when width & heigth in "parameters"
	double xLength = q.anchorPoints[1][0]; // only 10 of the 16 anchorpoints are important for the intersection point function ("quad function"), since the matrix A is symmetric
	double zLength = q.anchorPoints[2][0]; // therefore we can use 6 values in the lower left part (without the diagonal) to transfer other values to the shader (eg dimensions of a mirror/grating), we use a_21,a_31 for xlength and zlength
	r.weight = wasteBox(r.position[0],r.position[2],xLength,zLength, r.weight);
	
	outTransformation(r, q.inverseMisalignment, q.outTrans);
	return r;
}


void dynamicQuadrics(){
	
	//placeholder, info should later be transfered to shader
	const int maxBounces = 16;
	bool hitHitplane = false;
	uint beamlineIndex = uint(double(gl_GlobalInvocationID)/numberOfRaysPerBeamLine);
	Ray ray = rayData[uint(gl_GlobalInvocationID)];

	//iterate bounces
	if(!hitHitplane){
		for(int i = 0; i<maxBounces; i++){
			dvec4 closestHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 1.0/0.0); //infinity
			uint closestQuadricIndex;
			//find intersection points with all quadrics

			for(uint quadricIndex = uint(beamlineIndex)*uint(numberOfQuadricsPerBeamline); quadricIndex<numberOfQuadricsPerBeamline; quadricIndex++){
				dvec4 currentIntersection = intersectionPoint(quadricData[quadricIndex].anchorPoints, 1);
				if(length(ray.position - dvec3(closestHitpoint))>length(ray.position-dvec3(currentIntersection))){
					closestHitpoint = currentIntersection;
					closestQuadricIndex = quadricIndex;
				}
			}
			if(closestQuadricIndex == (beamlineIndex*numberOfQuadricsPerBeamline)-1){
				hitHitplane = true;
			}

			double type = quadricData[closestQuadricIndex].anchorPoints[3][0];
			//first quadric
			if (type == 0) { // mirror
				rayData[uint(gl_GlobalInvocationID)] = traceMirror(ray, quadricData[closestQuadricIndex], closestHitpoint);
			}else if(type == 1){ // plane grating
				rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(ray, quadricData[closestQuadricIndex], closestHitpoint);	
			}else if(type == 2){ // general grating
				rayData[uint(gl_GlobalInvocationID)] = traceGeneralGrating(ray, quadricData[closestQuadricIndex]);	
			}else{ // undefined
				rayData[uint(gl_GlobalInvocationID)] = ray;
			}

		}
	}
}
/*
void cameraPlaneIntersection(outputData, cameraPlane){	
	const int numberOfQuadrics = quadricData.length()
	Ray temporaryOutputVector;
	temporaryOutputVector = traceRay(outputData[uint(gl_GlobalInvocationID)], quadricData[numberOfQuadrics-1]);
	outputData[uint(gl_GlobalInvocationID)].position = temporaryOutputVector.position;
}
*/
void main(){
	//outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
	dynamicQuadrics();
	/*Ray r = rayData[uint(gl_GlobalInvocationID)];
	r.position = dvec3(r8_atan(r.position[0]), r8_atan(r.position[1]), r8_atan(r.position[2]));
	r.direction = dvec4(r8_atan(r.direction[0]), r8_atan(r.direction[1]), r8_atan(r.direction[2]), r8_atan(r.direction[3]));
	outputData[uint(gl_GlobalInvocationID)] =  r;
	*/
	// outputData[uint(gl_GlobalInvocationID)] = iterateQuadrics(rayData[uint(gl_GlobalInvocationID)]);
	// outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
	// outputData[uint(gl_GlobalInvocationID)].position = rayData[uint(gl_GlobalInvocationID)].position; // starts at (0,20,-20)
	// outputData[uint(gl_GlobalInvocationID)].direction = dvec4(0.0, 0.0, 0.0, 0.0); // hits the surface in 45 degree angle at (0,0,0) -> the normal should be (0,-1,0)
	
}
