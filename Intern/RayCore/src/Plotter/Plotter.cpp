#include "Plotter/Plotter.h"

#include <matplotlibcpp.h>

#include <algorithm>
#include <chrono>

#include "Debug/Debug.h"

namespace RAYX {
bool comp(Ray const& lhs, Ray const& rhs) { return lhs.m_extraParam < rhs.m_extraParam; }
bool abs_comp(double const& lhs, double const& rhs) { return abs(lhs) < abs(rhs); }
inline bool intclose(double x, double y) { return abs(x - y) < std::numeric_limits<double>::epsilon(); }
/**
 * @brief Plot the Data
 *
 * @param plotType Plot type, please check ENUM
 * @param plotName Plot Name
 * @param RayList Data to be plotted
 */
void Plotter::plot(int plotType, const std::string& plotName, const std::vector<Ray>& RayList, const std::vector<std::string>& OpticalElementNames) {
    RAYX_LOG << "Plotting...";
    if (plotType == plotTypes::LikeRAYUI)  // RAY-UI
        plotLikeRAYUI(RayList, plotName);
    else if (plotType == plotTypes::ForEach)
        RAYX_D_ERR << "Plot Type not supported";
    else if (plotType == plotTypes::Eachsubplot)
        plotforEach(RayList, plotName, OpticalElementNames);
}
/**
 * @brief Get the amount of bins for the histogram
 * FREEDMAN is a different method to get the "optimized" amount of bins
 *
 * @param vec Input Data Vector
 * @return int Bin Amount
 */
int Plotter::getBinAmount(std::vector<double>& vec) {
#ifdef FREEDMAN
    std::vector<double>::iterator b = vec.begin();
    std::vector<double>::iterator e = vec.end();
    std::vector<double>::iterator n3 = b;
    std::vector<double>::iterator n1 = b;
    const std::size_t q1 = 0.25 * std::distance(b, e);
    const std::size_t q3 = 0.75 * std::distance(b, e);
    std::advance(n1, q1);
    std::advance(n3, q3);

    double width = 2 * (*n3 - *n1) / std::pow(vec.size(), 1.0 / 3);
    return (int)std::ceil((*(std::max_element(vec.begin(), vec.end())) - *(std::min_element(vec.begin(), vec.end()))) / width);
#endif

    const double binwidth = 0.00125;
    auto xymax = std::max(*(std::max_element(vec.begin(), vec.end())), *(std::min_element(vec.begin(), vec.end())), abs_comp);
    return (int)(xymax / binwidth) + 1;
}
/**
 * @brief Plot final Image Plane
 *
 * @param RayList Data (Rays)
 * @param plotName
 */
void Plotter::plotLikeRAYUI(const std::vector<Ray>& RayList, const std::string& plotName) {
    // Sort Data for plotting
    std::vector<double> Xpos, Ypos;
    Xpos.reserve(RayList.size());
    Ypos.reserve(RayList.size());
    auto max = std::max_element(RayList.begin(), RayList.end(), comp);
    auto max_param = max->m_extraParam;

    // Create new RayList with right order
    for (auto r : RayList) {
        if (intclose(r.m_extraParam, max_param)) {
            Xpos.push_back(r.m_position.x);
            Ypos.push_back(r.m_position.y);
        }
    }
    auto maxX = *(std::max_element(Xpos.begin(), Xpos.end()));
    auto maxY = *(std::max_element(Ypos.begin(), Ypos.end()));
    // Start plot
    matplotlibcpp::figure_size(1300, 1000);
    matplotlibcpp::suptitle(plotName);

    matplotlibcpp::subplot2grid(4, 4, 0, 0, 1, 3);
    auto bin_amount_freedman = getBinAmount(Xpos);
    matplotlibcpp::hist(Xpos, bin_amount_freedman, "#0062c3", 0.65, false, {{"density", "False"}, {"histtype", "step"}});

    matplotlibcpp::subplot2grid(4, 4, 1, 0, 3, 3);
    matplotlibcpp::scatter(Xpos, Ypos, 1, {{"color", "#62c300"}, {"label", "Ray"}});
    matplotlibcpp::text(-maxX, -maxY, "Generated by RAY-X.");
    matplotlibcpp::xlabel("x / mm");
    matplotlibcpp::ylabel("y / mm");
    matplotlibcpp::legend();
    matplotlibcpp::grid(true);

    matplotlibcpp::subplot2grid(4, 4, 1, 3, 3, 1);
    bin_amount_freedman = getBinAmount(Ypos);
    matplotlibcpp::hist(Ypos, bin_amount_freedman, "#0062c3", 0.65, false,
                        {{"density", "False"}, {"orientation", "horizontal"}, {"histtype", "step"}});
    matplotlibcpp::title("Intensity");

    matplotlibcpp::show();
}
/**
 * @brief Plot for each intersection
 *
 * @param RayList Data (Rays)
 * @param plotName
 */
void Plotter::plotforEach(const std::vector<Ray>& RayList, const std::string& plotName, const std::vector<std::string>& OpticalElementNames) {
    // s is sorted and unique extraParam values extracted
    auto s = RayList;

    std::sort(s.begin(), s.end(), comp);  // Should be a fast enough sort
    s.erase(
        std::unique(s.begin(), s.end(),
                    [](Ray const& lhs, Ray const& rhs) { return abs(lhs.m_extraParam - rhs.m_extraParam) < std::numeric_limits<double>::epsilon(); }),
        s.end());
    auto uniqueCount = s.size();

    // Subplot in cols x cols
    int cols = (int)std::ceil(std::sqrt(uniqueCount));

    std::vector<double> Xpos, Ypos;
    Xpos.reserve(RayList.size());
    Ypos.reserve(RayList.size());

    double _size = 2.0;
    int i = 1;
    float _percent;
    matplotlibcpp::figure_size(cols * 500, (cols - 1) * 500);

    for (auto u : s) {
        for (auto r : RayList) {
            if (intclose(r.m_extraParam, u.m_extraParam)) {
                Xpos.push_back(r.m_position.x);
                Ypos.push_back(r.m_position.y);
            }
        }

        if (Xpos.size() > 50) {
            _size = 1.0;
        }

        _percent = (float)Xpos.size() / (float)RayList.size() * 100;

        matplotlibcpp::subplot(cols, cols, i);
        // TODO: A Call to PyObjectCall inside matplotlib-cpp can be slow depending on the data size
        matplotlibcpp::scatter(Xpos, Ypos, _size, {{"color", "#62c300"}, {"label", "Ray"}});
        matplotlibcpp::xlabel("x / mm");
        matplotlibcpp::ylabel("y / mm");
        matplotlibcpp::title(std::to_string((int)u.m_extraParam) + " (" + std::to_string(_percent) + "%)");

        matplotlibcpp::legend();

        i += 1;
        Xpos.clear();
        Ypos.clear();
    }
    matplotlibcpp::subplots_adjust({{"wspace", 0.35}, {"hspace", 0.35}});

    // matplotlibcpp::tight_layout();
    auto title = plotName;
    title = title + "Multiplot \n \n";
    int e = 1;
    for (const auto& element : OpticalElementNames) {
        title += " $\\it{" + std::to_string(e) + ": " + element + ((e % 3 != 0) ? " }$ ," : "}$\n");
        e++;
    }
    matplotlibcpp::suptitle(title);

    matplotlibcpp::show();
}
/**
 * @brief Plot and save custom benchmarked functions with -b arg
 *
 * @param BenchMap
 */
void Plotter::plotBenchmarks(const std::map<std::string, double>& BenchMap) {
    std::vector<double> times;
    std::vector<std::string> labels;
    std::vector<int> ticks(BenchMap.size());
    labels.reserve(BenchMap.size());
    times.reserve(BenchMap.size());

    std::iota(ticks.begin(), ticks.end(), 0);

    for (const auto& i : BenchMap) {
        labels.push_back(i.first);
        times.push_back(i.second);
    }

    // matplotlibcpp::figure_size(1300, 1000);
    RAYX_WARN << "plotBenchmarks not fully implemented";
    return;
    // matplotlibcpp::bar(times);
    // matplotlibcpp::xticks(ticks, labels);
    // matplotlibcpp::xlabel("Function Names");
    // matplotlibcpp::ylabel("Time (ms)");
    // matplotlibcpp::title("Benchmark results");
    // matplotlibcpp::save("Benchres");
}

}  // namespace RAYX
