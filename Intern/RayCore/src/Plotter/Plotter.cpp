#include "Plotter/Plotter.h"

#include <matplotlibcpp.h>

#include <algorithm>
#include <chrono>

#include "Debug/Debug.h"
// #define FREEDMAN
// #define LONGEST_PATH

namespace RAYX {
inline int last_obj(int extraParam) {
    if (std::to_string(extraParam).length() > 10) RAYX_ERR << "Extra Param is too long for plotting.";  // TODO: Use a different encoding
    while (extraParam > 10) {
        extraParam /= 10;
    }
    return extraParam;
}
bool last_comp(Ray const& lhs, Ray const& rhs) { return last_obj(lhs.m_extraParam) < last_obj(rhs.m_extraParam); }
bool comp(Ray const& lhs, Ray const& rhs) { return lhs.m_extraParam < rhs.m_extraParam; }
bool abs_comp(double const& lhs, double const& rhs) { return abs(lhs) < abs(rhs); }
inline bool int_close(double x, double y) { return abs(x - y) < std::numeric_limits<double>::epsilon(); }
/**
 * @brief Plot the Data
 *
 * @param plotType Plot type, please check ENUM
 * @param plotName Plot Name
 * @param RayList Data to be plotted
 */
void Plotter::plot(int plotType, const std::string& plotName, const std::vector<Ray>& RayList, const std::vector<std::string>& OpticalElementNames) {
    RAYX_LOG << "Plotting...";
    if (plotType == plotTypes::LikeRAYUI)  // RAY-UI
        plotLikeRAYUI(RayList, plotName, OpticalElementNames);
    else if (plotType == plotTypes::ForEach)
        RAYX_D_ERR << "Plot Type not supported";
    else if (plotType == plotTypes::Eachsubplot)
        plotforEach(RayList, plotName, OpticalElementNames);
}
/**
 * @brief Get the amount of bins for the histogram
 * FREEDMAN is a different method to get the "optimized" amount of bins
 *
 * @param vec Input Data Vector
 * @return int Bin Amount
 */
int Plotter::getBinAmount(std::vector<double>& vec) {
#ifdef FREEDMAN
    std::vector<double>::iterator b = vec.begin();
    std::vector<double>::iterator e = vec.end();
    std::vector<double>::iterator n3 = b;
    std::vector<double>::iterator n1 = b;
    const std::size_t q1 = 0.25 * std::distance(b, e);
    const std::size_t q3 = 0.75 * std::distance(b, e);
    std::advance(n1, q1);
    std::advance(n3, q3);

    double width = 2 * (*n3 - *n1) / std::pow(vec.size(), 1.0 / 3);
    return (int)std::ceil((*(std::max_element(vec.begin(), vec.end())) - *(std::min_element(vec.begin(), vec.end()))) / width);
#endif

    const double binwidth = 0.00125;
    auto xymax = std::max(*(std::max_element(vec.begin(), vec.end())), *(std::min_element(vec.begin(), vec.end())), abs_comp);
    return (int)(xymax / binwidth) + 1;
}
/**
 * @brief Plot final Image Plane
 *
 * @param RayList Data (Rays)
 * @param plotName
 */
void Plotter::plotLikeRAYUI(const std::vector<Ray>& RayList, const std::string& plotName, const std::vector<std::string>& OpticalElementNames) {
    // Sort Data for plotting
    std::vector<double> Xpos, Ypos;
    Xpos.reserve(RayList.size());
    Ypos.reserve(RayList.size());
    // Get elements that met Image plane (Last Element)
    auto max = std::max_element(RayList.begin(), RayList.end(), comp);

    auto max_param = last_obj(max->m_extraParam);
    if (max_param != (int)OpticalElementNames.size()) {
        RAYX_ERR << "No ray has hit the final optical element : " << OpticalElementNames.back();
    }
    // Create new RayList with right order
    for (auto r : RayList) {
#if defined(LONGEST_PATH)
        if (int_close(r.m_extraParam, max->m_extraParam)) {
#else
        if (last_obj(r.m_extraParam) == max_param) {
#endif
            Xpos.push_back(r.m_position.x);
            Ypos.push_back(r.m_position.y);
        }
    }
    auto minX = *(std::min_element(Xpos.begin(), Xpos.end()));
    auto minY = *(std::min_element(Ypos.begin(), Ypos.end()));
    // Start plot
    std::string title = plotName;
    matplotlibcpp::figure_size(1920, 1080);
    title += "\n" + OpticalElementNames.back();

    matplotlibcpp::suptitle(title);
    matplotlibcpp::subplot2grid(4, 4, 0, 0, 1, 3);
    matplotlibcpp::hist(Xpos, "sqrt", "#0062c3", 0.65, false, {{"density", "False"}, {"histtype", "step"}});

    matplotlibcpp::subplot2grid(4, 4, 1, 0, 3, 3);
    matplotlibcpp::scatter(Xpos, Ypos, 1, {{"color", "#62c300"}, {"label", "Ray(" + std::to_string(Xpos.size()) + ")"}});
    matplotlibcpp::text(minX, minY, "Generated by RAY-X.");
    matplotlibcpp::xlabel("x / mm");
    matplotlibcpp::ylabel("y / mm");
    matplotlibcpp::legend();
    matplotlibcpp::grid(true);

    matplotlibcpp::subplot2grid(4, 4, 1, 3, 3, 1);
    matplotlibcpp::hist(Ypos, "sqrt", "#0062c3", 0.65, false, {{"density", "False"}, {"orientation", "horizontal"}, {"histtype", "step"}});
    matplotlibcpp::title("Intensity");

    matplotlibcpp::show();
}  // namespace RAYX
/**
 * @brief Plot for each intersection
 *
 * @param RayList Data (Rays)
 * @param plotName
 */
void Plotter::plotforEach(const std::vector<Ray>& RayList, const std::string& plotName, const std::vector<std::string>& OpticalElementNames) {
    // sortedRayList is sorted and unique extraParam values extracted
    auto sortedRayList = RayList;

    std::sort(sortedRayList.begin(), sortedRayList.end(), comp);  // Should be a fast enough sort
    sortedRayList.erase(
        std::unique(sortedRayList.begin(), sortedRayList.end(),
                    [](Ray const& lhs, Ray const& rhs) { return abs(lhs.m_extraParam - rhs.m_extraParam) < std::numeric_limits<double>::epsilon(); }),
        sortedRayList.end());
    auto uniqueCount = sortedRayList.size();

    // Subplot in cols x cols
    int cols = (int)std::ceil(std::sqrt(uniqueCount));

    std::vector<double> Xpos, Ypos;
    Xpos.reserve(RayList.size());
    Ypos.reserve(RayList.size());

    double size = 2.0;
    int i = 1;
    float percent;
    matplotlibcpp::figure_size(cols * 500, (cols - 1) * 500);

    for (auto u : sortedRayList) {
        if (i / sortedRayList.size() > 9 / 10) RAYX_VERB << "Almost there...";  // Wakeup up call (Temp)
        for (auto r : RayList) {
            if (int_close(r.m_extraParam, u.m_extraParam)) {
                Xpos.push_back(r.m_position.x);
                Ypos.push_back(r.m_position.y);
            }
        }

        if (Xpos.size() > 50) {
            size = 1.0;
        }
        percent = (float)Xpos.size() / (float)RayList.size() * 100;

        try {
            // RAYX_LOG << (int)u.m_extraParam << ":" << Xpos.size();
            matplotlibcpp::subplot(cols, cols, i);
            // TODO: A Call to PyObjectCall inside matplotlib-cpp can be slow depending on the data size

            matplotlibcpp::scatter(Xpos, Ypos, size, {{"color", "#62c300"}, {"label", "Ray"}});
            matplotlibcpp::xlabel("x / mm");
            matplotlibcpp::ylabel("y / mm");
            matplotlibcpp::title(std::to_string((int)u.m_extraParam) + " (" + std::to_string(percent) + "%)");

            matplotlibcpp::legend();

            i += 1;
            Xpos.clear();
            Ypos.clear();
        } catch (const std::exception& e) {
            RAYX_ERR << "Error in matplotlib-cpp: " << e.what();
        }
    }
    matplotlibcpp::subplots_adjust({{"wspace", 0.35}, {"hspace", 0.35}});

    // matplotlibcpp::tight_layout();
    auto title = plotName;
    title = title + "Multiplot \n \n";
    int e = 1;
    for (const auto& element : OpticalElementNames) {
        title += " $\\it{" + std::to_string(e) + ": " + element + ((e % 3 != 0) ? " }$ ," : "}$\n");
        e++;
    }
    matplotlibcpp::suptitle(title);

    matplotlibcpp::show();
}
/**
 * @brief Plot and save custom benchmarked functions with -b arg
 *
 * @param BenchMap
 */
void Plotter::plotBenchmarks(const std::map<std::string, double>& BenchMap) {
    std::vector<double> times;
    std::vector<std::string> labels;
    std::vector<int> ticks(BenchMap.size());
    labels.reserve(BenchMap.size());
    times.reserve(BenchMap.size());

    std::iota(ticks.begin(), ticks.end(), 0);

    for (const auto& i : BenchMap) {
        labels.push_back(i.first);
        times.push_back(i.second);
    }

    // matplotlibcpp::figure_size(1300, 1000);
    RAYX_WARN << "plotBenchmarks not fully implemented";
    return;
    // matplotlibcpp::bar(times);
    // matplotlibcpp::xticks(ticks, labels);
    // matplotlibcpp::xlabel("Function Names");
    // matplotlibcpp::ylabel("Time (ms)");
    // matplotlibcpp::title("Benchmark results");
    // matplotlibcpp::save("Benchres");
}

}  // namespace RAYX
