//working shader

#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_gpu_shader_int64 : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;
// 3.14159265358979323846264338327950
const double PI = 3.14159265358979323846264338327950;
const uint64_t rngKey = (0xc8e4fd15 << 32) | 0x4ce32f6d;
const double inm2eV = 1.239852e3;

/* STRUCTS */

struct Ray{
	dvec3 position;
	double weight; // status of the ray (e.g if element missed -> 0)
	dvec3 direction;
	double energy;
	dvec4 stokes;
	double pathLength;
	double order;
	double lastElement;
	double extraParameter;
};
struct Element{
	dmat4 surfaceParams;
	dmat4 inTrans;
	dmat4 outTrans;
	dmat4 objectParameters;
	dmat4 elementParameters;
};

struct PalikEntry{
	double energy;
	double n;
	double k;
	double empty; // for padding
};

layout(std140, binding = 0) buffer ibuf
{
   Ray rayData[];
};

layout(std140, binding = 1) buffer obuf
{
   Ray outputData[];
};
layout(std140, binding = 2) buffer qbuf
{
	double numberOfBeamlines;
	double numberOfElementsPerBeamline;
	double numberOfRays;
	double numberOfRaysPerBeamLine;
	Element quadricData[];
};
layout(std140, binding = 3) buffer xyzbuf
{
	dvec4 xyznull[];
};

layout(binding = 4) buffer materialIndexBuf
{
	int nkpIdx[]; // can be indexed by material-index defined in Material.h to get the starting point of this material in the `nkp` table.
};
layout(binding = 5) buffer materialBuf
{
	PalikEntry nkp[]; // contains PALIK table of all materials concatenated together
};

#include "shader-include/approx.comp"
#include "shader-include/complex.comp"
#include "shader-include/random.comp"

/* HERE STARTS RAY TRACING CODE */

double hvlam(double x) {
    if(x==0) {
        return 0.0;
    }
    return inm2eV / x;
}

// multiplies position and direction of ray r with transformation matrix m
// r = dot(m, r)
Ray rayMatrixMult(Ray r, const dmat4 m) {
	r.position = dvec3(m * dvec4(r.position,1));
	r.direction = dvec3(m * dvec4(r.direction,0));
	return r;
}

Ray rotationAroundX(Ray r, double sin_psi, double cos_psi) {
	dmat4 rotation_matrix = dmat4(1, 0, 0, 0,
				0, cos_psi, -sin_psi, 0,
				0, sin_psi, cos_psi, 0,
				0,0,0,1);
	return rayMatrixMult(r, rotation_matrix);
}

/**
* uses given transformation matrix to transform ray position and direction into Object coordinates
* also takes misalignment of the object into account
* @param r				input ray in Ray-coordinates
* @param misalignment	4x4 homogeneous matrix that contains the misalignment of the element (dx, dy, dz, dphi, dpsi, dchi)
* @param inTrans		4x4 homogeneous matrix that contains the transformation of ray-coordinates to object coordinates (distance to previous element, grazing incidence angle, azimuthal angle)
*
* output: nothing. changes r in place
*/
void inTransformation(inout Ray r, const dmat4 misalignment, const dmat4 inTrans) {
	r.position = dvec3(misalignment * (inTrans *  dvec4(r.position,1)) );
	r.direction = dvec3(misalignment * (inTrans * dvec4(r.direction,0)));
}

/**
* uses given transformation matrix to transform ray position and direction back into Ray coordinates
* also takes misalignment of the object into account. Note that the order of the transformations is reversed and we use the inverse of the misalignment matrix
* @param r				input ray in Ray-coordinates
* @param invMisalignment	4x4 homogeneous matrix that contains the misalignment of the element (dx, dy, dz, dphi, dpsi, dchi)
* @param outTrans		3x3 homogeneous matrix (in 4x4 matrix for standardization) that contains the transformation of object coordinates to ray-coordinates (rotations only: grazing exit angle, neg. azimuthal angle)
*
* output: nothing. changes r in place
*/
void outTransformation(inout Ray r, const dmat4 invMisalignment, const dmat4 outTrans) {
	r.position = dvec3(outTrans * (invMisalignment * dvec4(r.position,1)));
	r.direction = dvec3(outTrans * (invMisalignment * dvec4(r.direction,0)));
}


// only for testing purposes. generally, each angle in the shader is in rad!!
double deg2rad(double degree) {
	// double PI = 3.141592653589793238462643383279502884197169399;//3 7 5 1 0 5 8 2 0 9 7 4 9 4 4 5 9
	return PI * degree / 180;
}

// dummy function for univariate random numbers
double[3] random_number(int n) {
	return double[3] (0.5,0.5,0.5);
}

// returns forial of a (from RAYLIB.for) (a!)
double fact(int a) {
	if(a < 0) {
		return a;
	}
	double f = 1;
	for(int i = 2; i<=a; i++) {
		f *= i;
	}
	return f;
}

/**
calculates direction cosini from angles phi,psi given in rad
@params r		ray whose direction vector is recalculated (inout)
		phi		horizontal angle in x-z-plane (pos.rotation, counterclockwise)
		phi		vertical angle in y-z-plane (pos.rotation, counterclockwise)
*/
void cosini(inout Ray r, double phi, double psi) {
	double cos_psi = r8_cos(psi);
	double cos_phi = r8_cos(phi);
	double sin_psi = r8_sin(psi);
	double sin_phi = r8_sin(phi);

	r.direction.x = cos_psi * sin_phi;
	r.direction.y = -sin_psi;
	r.direction.z = cos_psi * cos_phi;
}


/**
* checks whether the intersection point is within the extent of the surface
* @param x, z			 	x- and z-coordinates of the intersection point in element coordinates
* @param xLength, zLength	width and length of the optical element
* @param w 					current weight of the ray
*
* returns: unchanged weight if intersection point is within surface boundaries, 0.0 if not.
*/
double wasteBox(double x, double z, double xLength, double zLength, double w)
{
	if (xLength >= 0) { // Rectangular shape
		double x_min = -xLength/2.0;
		double x_max = xLength/2.0;
		double z_min = -zLength/2.0;
		double z_max = zLength/2.0;
		w *= int(x > x_min) * int(x < x_max) * int(z > z_min) * int(z < z_max); // This sets w to zero, if (x <= x_min || x >= x_max || z <= z_min || z >= z_max)
	} else {	// Ring shape
		double rd2 = (x/(xLength/2.0)) * (x/(xLength/2.0)) + (z/(zLength/2.0)) * (z/(zLength/2.0));
		w *= int(rd2 <= 1.0); // This sets w to zero, if (rd > 1.0)
	}
	return w;
}

// ! temporary for testing purposes (trapezoid)
double wasteBox(double x, double z, double xLengthA, double xLengthB, double zLength, double w)
{
	if (xLengthA >= 0){ // Rectangular shape
		if (xLengthB > 0){ // Trapezoid shape
			// Check point is within the trapezoid
			dvec3 P = dvec3(x,0,z);
			dvec3 A = dvec3(xLengthA/2.0, 0, zLength/2.0);
			dvec3 B = dvec3(-xLengthA/2.0, 0, zLength/2.0);
			dvec3 C = dvec3(xLengthB/2.0, 0, -zLength/2.0);
			dvec3 D = dvec3(-xLengthB/2.0, 0, -zLength/2.0);

			if (dot(cross(P-A, B-A), cross(P-D, C-D)) >= 0 || dot(cross(P-A, B-A), cross(P-D, C-D)) >= 0) {
				return 0.0;
			}
		}
		else {
			double x_min = -xLengthA/2.0;
			double x_max = xLengthA/2.0;
			double z_min = -zLength/2.0;
			double z_max = zLength/2.0;
			
			if (x <= x_min || x >= x_max || z <= z_min || z >= z_max) {
				return 0.0;
			}
		}
	}else{	// Ring shape
		double rd2 = (x/(xLengthA/2.0)) * (x/(xLengthA/2.0)) + (z/(zLength/2.0)) * (z/(zLength/2.0));
		if (rd2 > 1.0) {
			return 0.0;
		}
	}
	return w;
}

dvec2 getRefractiveIndex(double energy, int material) {
	if (material == -1) { // vacuum
		return dvec2(1., 0.);
	}

	int low = nkpIdx[material]; // <= energy
	int high = (material+1 < nkpIdx.length())? nkpIdx[material+1]-1 : nkp.length()-1; // >= energy

	// binary search
	while (high-low > 1) {
		int center = (low+high)/2;
		if (energy < nkp[center].energy) {
			high = center;
		} else {
			low = center;
		}
	}
	return dvec2(nkp[low].n, nkp[low].k); // return refractive index for energy level
}

// returns angle between ray direction and surface normal at intersection point
double getIncidenceAngle(Ray r, dvec4 normal) {
	normal = normalize(normal);
	double ar = dot(dvec3(normal), r.direction);
	// cut to interval [-1,1]
	if(ar < -1.0) ar = -1.0;
	else if(ar > 1.0) ar = 1.0;

	double theta = PI - r8_acos(ar);
	int gt = int(theta > PI/2);
	// theta in [0, pi]
	theta = gt * (PI - theta) + (1-gt) * theta;
	return theta;

}

/** calculates cosinus of transmittance angle with snell's law 
 * cosinus is needed in fresnel formula
 * sin(incidence_angle)² = 1 - cos(incidence_angle)²
 * ratio² = (cn1 / cn2)²
 * sin(transmittance_angle)² = (cn1 / cn2)² * sin(incidence_angle)²
 * cos(transmittance_angle) = sqrt( 1 - sin(transmittance_angle)²) 
 * 
 * @param cos_incidence			cosinus of complex incidence angle
 * @param cn1					complex refractive index of material from which the ray is coming
 * @param cn2					complex refractive index of material into which the ray is going
 * @return cos_transmittance 	cosinus of complex transmittance angle 
 */
dvec2 snell(dvec2 cos_incidence, dvec2 cn1, dvec2 cn2) {
	/*dvec2 sin_incidence = cx_sqrt( cx_sub(dvec2(1.0,0.0), cx_mul(cos_incidence, cos_incidence)) );
	dvec2 refractive_ratio = cx_div(cn1, cn2);
	dvec2 sin_transmittance = cx_mul(sin_incidence, refractive_ratio);
	dvec2 cos_transmittance = cx_sqrt( cx_sub(dvec2(1.0,0.0), cx_mul(sin_transmittance, sin_transmittance)));
	return cos_transmittance;*/
	dvec2 sin_incidence_square = cx_sub(dvec2(1.0,0.0), cx_mul(cos_incidence, cos_incidence)); // 1 - cos(inc)**2
	dvec2 refractive_ratio = cx_div(cn1, cn2); // cn1 / cn2
	dvec2 ratio_square = cx_mul(refractive_ratio, refractive_ratio);
	dvec2 sin_transmittance_square = cx_mul(sin_incidence_square, ratio_square); // sin(tr)**2 = sin(inc)**2 * (cn1/cn2)**2
	dvec2 cos_transmittance = cx_sqrt( cx_sub(dvec2(1.0,0.0), sin_transmittance_square) ); // cos = sqrt( 1 - ratio**2*sin(tr)**2 )
	return cos_transmittance;
}

/** calculates complex s- and p-polarization with fresnel formulas
 * @param cn1					complex refractive index of material from which the ray is coming
 * @param cn2					complex refractive index of material into which the ray is going
 * @param cos_incidence			cosinus of complex incidence angle
 * @param cos_transmittance 	cosinus of complex transmittance angle 
 * @return complex_S			complex s-polarization 
 * @return complex_P			complex p-polarization 
 *
 */
void fresnel(dvec2 cn1, dvec2 cn2, dvec2 cos_incidence, dvec2 cos_transmittance, inout dvec2 complex_S, inout dvec2 complex_P) {
	dvec2 mat1_incidence = cx_mul( cn1, cos_incidence ); // material one (incoming side)
	dvec2 mat1_transmittance = cx_mul( cn1, cos_transmittance );
	dvec2 mat2_incidence = cx_mul( cn2, cos_incidence ); // material two (into which the ray goes)
	dvec2 mat2_transmittance = cx_mul( cn2, cos_transmittance );

	complex_S = cx_div(cx_sub(mat1_incidence, mat2_transmittance) , cx_add(mat1_incidence, mat2_transmittance));
	complex_P = - cx_div(cx_sub(mat1_transmittance, mat2_incidence) , cx_add(mat1_transmittance, mat2_incidence));
	return;
}

/** computes complex s and p polarization over all layers with fresnel and snell's law
 * @param energy 				energy of ray
 * @param incidence_angle		normal incidence angle
 * @param material				material the photon collides with
 * @return complex_S			complex s-polarization
 * @return complex_P			complex p-polarization
 */
void reflectance(double energy, double incidence_angle, inout dvec2 complex_S, inout dvec2 complex_P, int material) {
	dvec2 cos_incidence = dvec2( r8_cos(incidence_angle), 0.0); // complex number, initialization only for first layer, the others are then derived from this with snell's law

	const int vacuum_material = -1;

	// todo number of layers: loop over layers from top to bottom, transmittance angle for each layer, so far only one layer (substrate?)
	// store cosinuses in array, bc needed in later loop for fresnel (or maybe only one loop is enough?)
	// todo refractive indices of materials in extra buffer?
	dvec2 cn1 = getRefractiveIndex(energy, vacuum_material);
	dvec2 cn2 = getRefractiveIndex(energy, material);
	dvec2 cos_transmittance = snell(cos_incidence, cn1, cn2);

	// todo again iterate over layers but from bottom to top, update s and p polarization in each iteration:
	fresnel(cn2, cn1, cos_transmittance, cos_incidence, complex_S, complex_P);
	// todo roughness (uses wavelength/energy)
	// todo other calculations for layers that are not substrate (which is the first layer)
	return;
}
/**
 * computes complex number a + i*b in euler form: 
 * euler = r * e^(i * phi) where r = sqrt(a**2 + b**2) = radius and phi = atan2(a,b) = (absolute) phase
 */
dvec2 cartesian_to_euler(dvec2 complex) {
	double r = dot(complex, complex); // r = sqrt(a**2 + b**"), why not take sqrt in fortran code?, maybe better bc square root looses precision
	dvec2 euler;
	if(r < 0 || r > 1) {
		euler = dvec2(1.0/0.0, 1.0/0.0);
		return euler;
	}
	euler = dvec2(r, r8_atan2(complex.y, complex.x)); // phi in rad
	return euler;
}

/** computes the difference in the phases of 2 complex number written in euler form: r * e^(i * phi)
 * @param euler1 		first complex number // s 
 * @param euler2		second complex number // p
 * @return delta = phi1 - phi2, in [-pi/2, pi/2] degrees
 */
double phase_difference(dvec2 euler1, dvec2 euler2) {
	double delta = euler2.y - euler1.y; // p - s
	delta = delta - int(delta > 180)*360.0 + int(delta < -180)*360.0;
	return delta;
}

/** efficiency calculation
 * uses complex numbers for s- and p-polarisation: 
 * complex_S = a + i*b as dvec2. 
 * in euler form: complex_S = r * e^(i * phi) where r = sqrt(a**2 + b**2) = radius and phi = atan2(a,b) = (absolute) phase
 * @param real_S				inout, s-polarization (senkrecht), radius of complex number
 * @param real_P				inout, p-polarization (parallel), radius of complex number
 * @param delta					phase difference between angles of complex numbers complex_S, complex_P
 * @param incidence_angle		normal incidence angle
 * @param material				material the photon collides with
 * @param others
 */
void efficiency(Ray r, out double real_S, out double real_P, out double delta, double incidence_angle, int material) {
	dvec2 complex_S, complex_P;
	reflectance(r.energy, incidence_angle, complex_S, complex_P, material);

	dvec2 euler_P = cartesian_to_euler(complex_P);
	dvec2 euler_S = cartesian_to_euler(complex_S);

	delta = phase_difference(euler_S, euler_P);
	real_S = euler_S.x;
	real_P = euler_P.x;
}

/** creates a Müller matrix (see p. 32 of Schäfers, 2007)
 * @param R_s
 * @param R_p
 * @param delta
 *
 */
dmat4 muller_matrix(double R_s, double R_p, double delta) {
    double c = r8_cos(delta);
    double s = r8_sin(delta);
	return dmat4(
		(R_s + R_p)/2.0, (R_p - R_s)/2.0,        0.0,       0.0,
		(R_p - R_s)/2.0, (R_s + R_p)/2.0,        0.0,       0.0,
		            0.0,             0.0,  R_s*R_p*c, R_s*R_p*s,
		            0.0,             0.0, -R_s*R_p*s, R_s*R_p*c
	);
}

/** returns updated stokes vector
 * @param r			ray
 * @param real_S	real part of the complex s-polarization
 * @param real_P	real part of the complex p-polarization
 * @param delta		phase difference between complex s and p polarization
 * @param azimuthal	angle of rotation of element in xy plane (chi + dchi (misalignment))
 * @returns updated stokes vector of ray, updates weight of ray
 */
void update_stokes(inout Ray r, double real_S, double real_P, double delta, double azimuthal, inout uint64_t ctr) {
	dvec4 stokes_old = r.stokes;
	double c_chi = r8_cos(azimuthal);
	double s_chi = r8_sin(azimuthal);
	dmat4 rot = dmat4(1, 0, 0, 0,
					0, c_chi, -s_chi, 0,
					0, s_chi, c_chi, 0,
					0, 0, 0, 1);
	dmat4 inv_rot = transpose(rot);

	dvec4 stokes_new = muller_matrix(real_S, real_P, delta) * rot * stokes_old;;
	r.stokes = inv_rot * stokes_new;

	double rn = squaresDoubleRNG(ctr);
	// throw ray away with certain probability
	if((r.stokes.x / stokes_old.x) - rn <= 0) r.weight = 0;
	return;
}

/**
turn the normal vector through x_rad and z_rad
@params:  	normal: the normal vector
			x_rad: angle in rad for x-axis
			z_rad: angle in rad for z-axis
returns modified normal vector
*/
dvec4 normal_cartesian(dvec4 normal, double x_rad, double z_rad){
	double FX = normal[0];
	double FY = normal[1];
	double FZ = normal[2];

	double cosx = r8_cos(x_rad);
	double sinx = r8_sin(x_rad);
	double cosz = r8_cos(z_rad);
	double sinz = r8_sin(z_rad);

	// put in matrix mult?
	double FY2 = FY*cosz + FZ*sinz;
	normal[0] = FX*cosx + FY2*sinx;
	normal[1] = FY2*cosx - FX*sinx;
	normal[2] = FZ*cosz - FY*sinz;

	return normal;
}

/**
turn the normal vector through x_rad and z_rad
@params:  	normal: the normal vector
			x_rad: angle in rad for x-axis
			z_rad: angle in rad for z-axis
returns modified normal vector
*/
dvec4 normal_cylindrical(dvec4 normal, double x_rad, double z_rad) {
	double normFXFY = sqrt(normal[0]*normal[0] + normal[1]*normal[1]);
	double arcTanFXFY = r8_atan2(normal[1], normal[0]);
	double sinz = r8_sin(z_rad);
	double cosz = r8_cos(z_rad);

	normal[0] = r8_cos(x_rad+arcTanFXFY)*(normFXFY*cosz+normal[2]*sinz);
	normal[1] = r8_sin(x_rad+arcTanFXFY)*(normFXFY*cosz+normal[2]*sinz);
	normal[2] = normal[2]*cosz-normFXFY*sinz;

	return normal;

}

/**
adds slope error to the normal
@params:
	normal: normal vector
	slopeX: sigma-slope error in x-y plane (chi) (RMS) in arcsec
	slopeZ: sigma-slope error in y-z plane (psi) (RMS) in arcsec
	O_type: cartesian or cylindrical type of slope error (0=cartesian, 1=cylindrical) (1 only for ellipsis relevant)
returns new normal if there is a slope error in either x or z direction or the unmodified normal otherwise.
*/
dvec4 tanger(dvec4 normal, double slopeX, double slopeZ, int O_type, inout uint64_t ctr) {
	// only calculate the random number if at least one slope error is not 0, since the calculation is costly (sin, cos, log involved)
	if(slopeX != 0 || slopeZ != 0) {
		double random_values[2] = double[2] (squaresNormalRNG(ctr, 0, slopeX), squaresNormalRNG(ctr, 0, slopeZ));

		/*double x = random_values[0] * slopeX; // to get normal distribution from std.-norm. multiply by sigma (=slopeX) -> mu + x * sigma but mu=0 here
		double z = random_values[1] * slopeZ;*/

		double x_rad = deg2rad(random_values[0]/3600.0);
		double z_rad = deg2rad(random_values[1]/3600.0);

		if (O_type == 0) { // default
			normal = normal_cartesian(normal, x_rad, z_rad);
		}else if(O_type == 1) {
			normal = normal_cylindrical(normal, x_rad, z_rad);
		}
	}

	return normal;
}


/**
calculates DX and DZ (line spacing in x and z direction) at a given point for a given direction on the grating
@params: lots
@returns: (inplace) DX, DZ
*/
void RZPLineDensity(Ray r, dvec4 normal, int IMAGE_TYPE, int RZP_TYPE, int DERIVATION_METHOD, double zOffsetCenter,
double risag, double rosag, double rimer, double romer, double alpha, double beta, double Ord, double WL,
inout double DX, inout double DZ) {

	double FX = normal.x;
	double FY = normal.y;
	double FZ = normal.z;
	double X = r.position.x;
	double Y = r.position.y;
	double Z = r.position.z;

	if(RZP_TYPE == 1) // meridional (wie VLS grating)
		X = 0;

	// avoid calculating the same sinus/cosinus multiple times (costly)
	double s_beta = r8_sin(beta);
	double c_beta = r8_cos(beta);
	double s_alpha = r8_sin(alpha);
	double c_alpha = r8_cos(alpha);

	/*if (DERIVATION_METHOD == 1) {
		DX = getLineDensity1d(ptr_dx,x,z);
		DZ = getLineDensity1d(ptr_dz,x,z);
		return;
	}*/
	double xi;
	double yi;
	double zi;
	double xm;
	double ym;
	double zm;

	if(IMAGE_TYPE == 0) { // point to point (standard)
		if(FX == 0 && FZ == 0) { // plane
			zi = -(risag * c_alpha+Z);
			xi = X;
			yi = risag * s_alpha;
			zm = rosag * c_beta - Z;
			xm = X;
			ym = rosag * s_beta;
		}else{ // more general case, can be reduced to the plane with normal = (0,1,0) and y = 0
			zi = FX*FZ*X - (FX*FX + FY*FY)*(Z + risag*c_alpha) + FY*FZ*(Y - risag*s_alpha);
			xi = (FY*X - FX*Y + FX*risag*s_alpha);
            yi = -(FX*X) - FY*Y - FZ*Z - FZ*risag*c_alpha + FY*risag*s_alpha;
            zm = FX*FZ*X + (FX*FX + FY*FY)*(-Z + rosag*c_beta) + FY*FZ*(Y - rosag*s_beta);
            xm = (FY*X - FX*Y + FX*rosag*s_beta);
            ym = -(FX*X) - FY*Y - FZ*Z + FZ*rosag*c_beta + FY*rosag*s_beta;
		}
	}else if(IMAGE_TYPE == 1){ // astigmatic to astigmatix
		double s_rim = sign(rimer);
		double s_rom = sign(romer);
		double c_2alpha = r8_cos(2*alpha);
		double c_2beta = r8_cos(2*beta);
		if(FX == 0 && FZ == 0){ //   !plane

			zi = s_rim*(rimer*c_alpha+Z);
        	xi =(s_rim*X*(c_alpha*Z-2*s_alpha*s_alpha*rimer+s_alpha*Y+rimer)) / (c_alpha*Z-2*s_alpha*s_alpha*risag+s_alpha*Y+risag);
            yi = s_rim*(-rimer*s_alpha+Y);
            zm = s_rom*(romer*c_beta-Z);
            xm = (s_rom*X*(-c_beta*Z-2*s_beta*s_beta*romer+s_beta*Y+romer)) / (c_beta*Z+2*s_beta*s_beta*rosag-s_beta*Y-rosag);
            ym = s_rom*(romer*s_beta-Y);
		}else{
			double denominator = Z*c_alpha + risag*c_2alpha + Y*s_alpha;
			double nominator = X*(Z*c_alpha + rimer*c_2alpha + Y*s_alpha);
			zi = s_rim*((FX*FX + FY*FY)*(Z + rimer*c_alpha) - FY*FZ*(Y - rimer*s_alpha) - (FX*FZ*nominator) / denominator);
			xi = s_rim*(-(FX*Y) + FX*rimer*s_alpha + (FY*nominator) / denominator);
			yi = s_rim*(FZ*(Z + rimer*c_alpha) + FY*(Y - rimer*s_alpha) + (FX*nominator) / denominator);

			denominator = (-(Z*c_beta) + rosag*c_2beta + Y*s_beta);
			nominator = X*(-(Z*c_beta) + romer*c_2beta + Y*s_beta);
			zm = s_rom*((FX*FX + FY*FY)*(-Z + romer*c_beta) + FY*FZ*(Y - romer*s_beta) + (FX*FZ*nominator)/denominator);
			xm = s_rom*(FX*(Y - romer*s_beta) - (FY*nominator)/denominator);
			ym = s_rom*(FZ*(-Z + romer*c_beta) + FY*(-Y + romer*s_beta) - (FX*nominator)/denominator);
		}
		double ris = sqrt(zi*zi + xi*xi + yi*yi);
		double rms = sqrt(zm*zm + xm*xm + ym*ym);

		double ai = zi/ris;
		double bi = -xi/ris;
		double am = -zm/rms;
		double bm = xm/rms;

		//double ci = yi/ris; // for what?
		//double cm = -ym/rms;

		DZ = (ai+am)/(WL*Ord);
		DX = (-bi-bm)/(WL*Ord);

		return;
	}

	double ris = sqrt(zi*zi + xi*xi + yi*yi);
    double rms = sqrt(zm*zm + xm*xm + ym*ym);

	double ai = xi/ris;
	double am = xm/rms;
	double bi = zi/ris;
	double bm = zm/rms;


	DX = (ai+am)/(WL*Ord);
	DZ = (-bi-bm)/(WL*Ord);

	return;

}

/**
calculates refracted ray
@params: 	r: ray
			normal: normal at intersection point of ray and element
			az: line spacing in z direction
			ax: line spacing in x direction
@returns: refracted ray (position unchanged, direction changed), weight = 0 if "ray beyond horizon"
*/
Ray refrac2D(Ray r, dvec4 normal, double az, double ax) {
	double eps1 = -r8_atan(normal.x/normal.y);
    double del1 = r8_asin(normal.z);

	double cos_d = r8_cos(-del1);
	double sin_d = r8_sin(-del1);
	double cos_e = r8_cos(-eps1);
	double sin_e = r8_sin(-eps1);
	dmat3 rot = dmat3(cos_e, cos_d*sin_e, sin_d*sin_e,
				-sin_e, cos_d*cos_e, sin_d*cos_e,
				0, -sin_d, cos_d);
	dmat3 inv_rot = dmat3(cos_e, -sin_e, 0,
				cos_d*sin_e, cos_d*cos_e, -sin_d,
				sin_d*sin_e, sin_d*cos_e, cos_d);
	r.direction = rot * r.direction;

	double x1 = r.direction.x - ax;
	double z1 = r.direction.z - az;
	double y1 = 1-x1*x1-z1*z1;

	if (y1 > 0){
	   y1 = sqrt(y1);

	   r.direction.x = x1;
	   r.direction.y = y1;
	   r.direction.z = z1;
	}else{ // beyond horizon - when divergence too large
	   r.weight = 0.0;
	}
	r.direction = inv_rot * r.direction;
	return r;
}

// refraction function used for gratings
Ray refrac(Ray r, dvec4 normal, double linedensity){
	double xy = normal[0] / normal[1];
	double zy = normal[2] / normal[1];
	double sqq = sqrt(1 + zy*zy + xy*xy);
	double an_x = xy/sqq;
	double an_y = -1.0/sqq;
	double an_z = zy/sqq;

	double eps1 = r8_atan(an_x/ an_y); //-atan(an_x/an_z) around z, chi
	double del1 = r8_asin(an_z); // sign(an_z) * r8_atan(sqrt( (an_z*an_z) / (1-an_z*an_z) )); // -asin(an_z); // -asin around x, psi
	double cos_d = r8_cos(del1);
	double a1 = linedensity * cos_d;
	double sin_d = r8_sin(-del1);
	double cos_e = r8_cos(-eps1);
	double sin_e = r8_sin(-eps1);
	dmat4 rot = dmat4(cos_e, cos_d*sin_e, sin_d*sin_e, 0,
				-sin_e, cos_d*cos_e, sin_d*cos_e, 0,
				0, -sin_d, cos_d, 0,
				0,0,0,1);
	dmat4 inv_rot = dmat4(cos_e, -sin_e, 0, 0,
				cos_d*sin_e, cos_d*cos_e, -sin_d, 0,
				sin_d*sin_e, sin_d*cos_e, cos_d, 0,
				0,0,0,1);
	r.direction = dvec3(rot * dvec4(r.direction,0));

	double y1 = (r.direction[1]*r.direction[1]+r.direction[2]*r.direction[2]-((r.direction[2]-a1)*(r.direction[2]-a1)));
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] -= a1;
	}else{
	   r.weight = 0.0;
	}
	r.direction = dvec3(inv_rot * dvec4(r.direction,0));
	return r;
}


/** variable line spacing for gratings
@params
	lineDensity: general line density?
	z: z-coordinate of ray position
	vls[6]: 6 vls parameters given by user
@returns line density specifically for this z-coordinate
*/
double vlsGrating(double lineDensity, double z, double[6] vls) {
	// lineDensity = lineDensity * (1 + 2*b2*z + 3*b3*z**2 + 4*b4*z**3 + 5*b5*z**4 + 6*b6*z**5 + 7*b7*z**6)
	double z2 = z*z;
	double z3 = z2*z;
	double z4 = z3*z;
	double z5 = z4*z;
	double z6 = z5*z;
	double a = lineDensity * (1 + 2*vls[0]*z + 3*vls[1]*z2 + 4*vls[2]*z3 + 5*vls[3]*z4 + 6*vls[4]*z5 + 7*vls[5]*z6);
	return a;
}


/*
* simplified refraction function used for plane gratings
* normal is always the same (0,1,0) -> no rotation and thus no trigonometric functions necessary
* @param r			ray
* @param normal		normal at ray-object intersection (for planes always (0,1,0))
* @param a			a = WL * D0 * ORD * 1.e-6  with D0: line density (l/mm); WL:wavelength (nm); ORD order of diffraction
*/
Ray refrac_plane(Ray r, dvec4 normal, double a){
	double y1 = r.direction[1]*r.direction[1] + r.direction[2]*r.direction[2] - (r.direction[2]-a)*(r.direction[2]-a);
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] = r.direction[2] - a;
	}else{
	   r.weight = 0.0; // status?
	}
	return r;
}

/**
checks whether the ray is hit by a central beam stopper which may be rectangular (width: xStop/yStop)
or circular.
if so the ray is thrown away.
if xStop is negative, then a circular shape of radius xStop is assumed (from RAY.FOR)
@params		x,y				x/y-coord. of ray direction
			xStop, yStop	shape of beam stopper
			weight			current weight of the ray, is changed if ray is stopped
@return
	new weight
*/
double stopBox(double x, double y, double xStop, double yStop, double weight) {
	double w = weight;
	// if w == 0 return
	if(w != 0) {
		if(xStop > 0) {
			if(abs(x) < xStop && abs(y) < yStop) {
				w = 0;
			}
		}else{
			double radius = sqrt((x/xStop)*(x/xStop) + (y/yStop)*(y/yStop));
			if(radius <= 1) w = 0;
		}
	}
	return w;
}

/**returns first bessel function of parameter v*/
double bessel1(double v) {
	if(v < 0.0 || v > 20.0) {
		return 0.0;
	}

	double sum = 0;
	int large = 30;

	double PO1;
	double PO2;
	double FA1;
	for(int small = 0; small<=large; small++) {
		PO1 = dpow(-1.0, small);
		PO2 = dpow(v/2.0, 2*small+1);
		FA1 = fact(small);
		sum += (PO1 / (FA1*FA1*(small+1))) * PO2;
	}
	return sum;
}

/**
calculates the Bessel diffraction effects on circular slits and on circular zoneplates
@params:	radius		radius < 0 (mm)
			wl			wavelength (nm)
			dphi, dpsi  angles of diffracted ray
@returns
	results stored in dphi, dpsi (inout)
*/
void bessel_diff(double radius, double wl, inout double dphi, inout double dpsi, inout uint64_t ctr) {
	double b = abs(radius) * 1e06;
	double ximax = 5.0*wl/b;

	double rn1[3];
	double c = -1;
	while(c < 0) { // while c = wd - rn1[2] < 0 continue
		rn1 = double[3] (squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		dphi = rn1[0] * ximax;
		dpsi = rn1[1] * ximax;
		double xi = sqrt(0.5 * (dphi*dphi + dpsi*dpsi));
		double u = 2.0 * PI * b * xi / wl;
		double wd = 1;
		if(u != 0) {
			wd = 2.0 * bessel1(u) / u;
			wd = wd*wd;
		}
		c = wd - rn1[2];
	}

	// 50% neg/pos sign
	dphi = sign(squaresDoubleRNG(ctr) - 0.5) * dphi;
	dpsi = sign(squaresDoubleRNG(ctr) - 0.5) * dpsi;

}

/**
* calculates fraunhofer diffraction effects on rectangular slits
* @param dim		dimension (x or y) (mm)
* @param wl			wavelength (nm)
* @param dAngle 	diffraction angle (inout)
* @param ctr		counter for random number generator
* @return result stored in dAngle
*/
void fraun_diff(double dim, double wl, inout double dAngle, inout uint64_t ctr){
	if (dim==0) return; // no diffraction in this direction
	double b = dim * 1e06; 		// slit opening
	double div = 10.0 * wl/b;	// up to 2nd maximum

	double rna[2]; // 2 uniform random numbers in [0,1]
	double c = -1;
	while(c < 0) { // while c = wd - uni[1] < 0 continue
		rna = double[2] (squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		dAngle = (rna[0]-0.5) * div;
		double u = PI * b * r8_sin(dAngle) / wl;
		double wd = 1;
		if(u != 0) {
			wd = r8_sin(u) / u;
			wd = wd*wd;
		}
		c = wd - rna[1];
	}
}

void diffraction(int iopt, double xLength, double yLength, double wl, inout double dPhi, inout double dPsi, inout uint64_t ctr) {
	if(wl <= 0) return;

	double yl = yLength;
	double xl = xLength;

	if(xLength > 0) {	// rectangular slit, zoneplate
		if(iopt == 3) { 	// zoneplate
			if(yLength > 0) {	// in x direction
				yl = 0;
			}
			else if(yLength < 0) { // in y direction, what about ==0?
				xl = 0;
			}
		}
		fraun_diff(xl, wl, dPhi, ctr);
		fraun_diff(yl, wl, dPsi, ctr);
	}else{	// circular slit
		if(iopt == 1){
			xl = yLength; // SL R_max
		}
		bessel_diff(xl, wl, dPhi, dPsi, ctr);
	}
}

#include "shader-include/intersection.comp"
#include "shader-include/trace.comp"

/*
* iterate through all elements (sequentially) and trace rays element by element
*/
void iterateElements(){ // unused
	double type;
	uint numberOfElements = quadricData.length();
	// ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random numbter
	uint64_t workerCounterNum = (~(uint64_t(0)) / uint64_t(numberOfRays));
	uint64_t ctr = uint(gl_GlobalInvocationID) * workerCounterNum;
	
	for(int i=0; i<numberOfElementsPerBeamline; i++){
		Element e = quadricData[i];

		type = int(e.surfaceParams[3][0]);
		dvec4 intersection = getOpticalElementIntersection(rayData[uint(gl_GlobalInvocationID)], i);
		
		if (type == 0) { // mirror
			rayData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);
		}else if(type == 1){ // plane grating
			rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 2){ // general grating
			rayData[uint(gl_GlobalInvocationID)] = traceGeneralGrating(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 3){ // Slit
			rayData[uint(gl_GlobalInvocationID)] = traceSlit(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 4) { // rzp
			rayData[uint(gl_GlobalInvocationID)] = traceRZP(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 5) { // image plane
			rayData[uint(gl_GlobalInvocationID)] = traceImagePlane(rayData[uint(gl_GlobalInvocationID)], i, intersection);
		}else if(type == 6) { // toroid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceToroid(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}else if(type == 7) { // ellipsoid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceEllipsoidMirror(rayData[uint(gl_GlobalInvocationID)], i, ctr, intersection);	
		}
		//rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], q.outTrans);
	}
	outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}

// dynamic ray tracing -> check which ray hits which element first
// in this function we need to make sure that rayData ALWAYS remains in GLOBAL coordinates (it can be changed in a function but needs to be changed back before the function returns to this function)
void dynamicElements(){
	const int numberOfElements = quadricData.length();
	//placeholder, info should later be transfered to shader
	const int maxBounces = numberOfElements;
	Ray ray = rayData[uint(gl_GlobalInvocationID)];
	uint beamlineIndex = uint(double(gl_GlobalInvocationID)/numberOfRaysPerBeamLine);
	int whichIntersection = 1;

	// ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random number
	uint64_t workerCounterNum = (~(uint64_t(0)) / int(numberOfRays));
	uint64_t ctr = uint(gl_GlobalInvocationID) * workerCounterNum;
	int type = -1;

	int closestElementIndex = -1;
	int lastClosestElementIndex;
	dvec4 closestHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 0.0);
	dvec4 closestGlobalHitpoint;
	double threshold = 0.001;
	
	Element next;
	double bounce = 1;
	//iterate bounces
	for(int i = 0; i<maxBounces; i++){
		ray = rayData[uint(gl_GlobalInvocationID)];

		// last traced element
		lastClosestElementIndex = closestElementIndex;
		// index of element with current closest intersection with ray, initialized with -1
		closestElementIndex = -1;
		// global coordinates of first intersection point of ray among all elements in beamline
		closestHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 0);
		closestGlobalHitpoint = dvec4(1.0/0.0, 1.0/0.0, 1.0/0.0, 0);

		//find intersection points with all elements
		for(int elementIndex = int(beamlineIndex)*int(numberOfElementsPerBeamline); elementIndex<(beamlineIndex+1)*numberOfElementsPerBeamline; elementIndex++){
		//for(int elementIndex = 0; elementIndex<numberOfElements; elementIndex++){
			if(elementIndex == lastClosestElementIndex){
				//TODO: self-intersection
				//rayData[uint(gl_GlobalInvocationID)].weight = 11;
				continue;
			}
			//dvec4 currentIntersection = dvec4(1.0/0.0,1.0/0.0,1.0/0.0, 0.0);
			dvec4 currentIntersection = getOpticalElementIntersection(ray, elementIndex);
			
			// intersection coordinates in global coordinates 
			dvec4 currentGlobalIntersection;
			currentGlobalIntersection.xyz = dvec3(quadricData[elementIndex].outTrans *  dvec4(currentIntersection.xyz,1));
			// check if current intersection is closer than the closest previous Hitpoint
			if(length(ray.position - closestGlobalHitpoint.xyz) > length(ray.position-currentGlobalIntersection.xyz) && currentIntersection.w != 0){
				closestHitpoint = currentIntersection;
				closestGlobalHitpoint = currentGlobalIntersection;
				closestElementIndex = elementIndex;
			}
		}
		
		if(closestElementIndex == -1){ // no element was hit
			break;
		}

		// transform ray and intersection point in ELEMENT coordiantes
		next = quadricData[closestElementIndex];
		rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], next.inTrans);
	
		// calculate interaction of ray with detected next element 
		type = int(next.surfaceParams[3][0]);
		if (type == 0) { // plane + sphere mirror
			rayData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint); // intersection in ELEMENT coordinates
		}else if(type == 1){ // plane grating
			rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 2){ // general grating
			rayData[uint(gl_GlobalInvocationID)] = traceGeneralGrating(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 3){ // Slit
			rayData[uint(gl_GlobalInvocationID)] = traceSlit(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 4) { // rzp
			rayData[uint(gl_GlobalInvocationID)] = traceRZP(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}else if(type == 5) { // image plane
			rayData[uint(gl_GlobalInvocationID)].extraParameter += (closestElementIndex+1) * bounce;
			rayData[uint(gl_GlobalInvocationID)].lastElement = closestElementIndex+1;
			outputData[uint(gl_GlobalInvocationID)] = traceImagePlane(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, closestHitpoint);
			return;
		}else if(type == 6) { // toroid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceToroid(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);
		}else if(type == 7) { // ellipsoid mirror
			rayData[uint(gl_GlobalInvocationID)] = traceEllipsoidMirror(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);	
		}
		// use extraParameter to store the order in which the ray has hit which optical element (e.g extraParameter = 412 -> first hit element 2, then 1, then 4)
		rayData[uint(gl_GlobalInvocationID)].extraParameter += ((closestElementIndex+1) * bounce) * int(rayData[uint(gl_GlobalInvocationID)].lastElement == closestElementIndex+1);
		bounce *= pow(10, int(rayData[uint(gl_GlobalInvocationID)].lastElement == closestElementIndex+1));
		// transform back to world coordinates
		rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], next.outTrans);
	
	}
	// end the tracing in element coordinates (makes comparison with old RAY easier)
	//rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], next.inTrans); 
	outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}


void testFunctions() {
	// flag to decide how to interpret the input
	int settings = int(quadricData[0].surfaceParams[3][1]);

	// use dynamic tracing for the given beamline (no unit test)
	if(settings==0) {
		dynamicElements();
		return;
	}
	 
	// ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random numbter
	uint64_t workerCounterNum = (~(uint64_t(0)) / uint64_t(numberOfRays));
	uint64_t ctr = uint(gl_GlobalInvocationID) * workerCounterNum;
	
	Ray r = rayData[uint(gl_GlobalInvocationID)];
	Ray res; // store the result here
	// initialize with 0's
	res.position = dvec3(0,0,0);
	res.direction = dvec3(0,0,0);
	res.energy = 0;
	res.weight = 0;
	res.stokes = dvec4(0,0,0,0);
	res.pathLength = 0;
	res.extraParameter = 0;
	res.order = 0;
	res.lastElement = 0;
	
	// settings != 0 -> unit test cases in test_shader.cpp
	// input rays and elements are interpreted depending on the test case
	if(settings == 1) { // TEST TRIG FUNCTIONS: sin
		res.position = dvec3(r8_sin(r.position.x), r8_sin(r.position.y),r8_sin(r.position.z));
		res.weight = r8_sin(r.weight);
		res.direction = dvec3(r8_sin(r.direction.x), r8_sin(r.direction.y), r8_sin(r.direction.z));
		res.energy = r8_sin(r.energy);
		res.stokes = dvec4(r8_sin(r.stokes[0]), r8_sin(r.stokes[1]), r8_sin(r.stokes[2]), r8_sin(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 2) { // test refrac
		res = refrac(r, dvec4(r.position, 0), r.weight); // need quadric buffer to put calculated parameter to shader
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 3) { // test plane refrac
		Ray r = rayData[uint(gl_GlobalInvocationID)];
		// refrac_plane(ray, normal, a) only y and z direction of ray are needed
		// a encoded in weight, normal encoded in r.position
		r = refrac_plane(r, dvec4(r.position, 0), r.weight);
		res.direction = r.direction;
		res.weight = r.weight;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 4) { // test vls grating
		double b_params[6] = double[6] (r.position.x,r.position.y,r.position.z, r.direction.x,r.direction.y,r.direction.z);//(0.1,0.1,0.1,0.01,0.02,0.03);
		double z = r.energy;
		double a = r.weight;
		res.weight = vlsGrating(a, z, b_params);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 5) { // diffraction
		// double bessel1(double v)
		// void bessel_diff(double radius, double wl, inout double dphi, inout double dpsi)
		// void diffraction(int iopt, double xLength, double yLength, double wl, inout double dPhi, inout double dPsi)
		// void fraun_diff(double dim, double wl, inout double dAngle)
		double dPhi;
		double dPsi;
		int iopt = int(r.position.x);
		double xLength = r.position.y;
		double yLength = r.position.z;
		double wl = r.weight;
		diffraction(iopt, xLength, yLength, wl, dPhi, dPsi, ctr);
		res.position.x = dPhi;
		res.position.y = dPsi;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 6) { // bessel1 function
		res.position = dvec3(bessel1(r.position.x),bessel1(r.position.y),bessel1(r.position.z));
		res.direction = dvec3(bessel1(r.direction.x),bessel1(r.direction.y),bessel1(r.direction.z));
		res.weight = bessel1(r.weight);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 7) { // double pow test
		res.position.x = dpow(r.position.x, int(r.direction.x));
		res.position.y = dpow(r.position.y, int(r.direction.y));
		res.position.z = dpow(r.position.z, int(r.direction.z));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 8) { // factorial f(a) = a! test
		res.position = dvec3(fact(int(r.position.x)), fact(int(r.position.y)), fact(int(r.position.z)));
		res.direction = dvec3(fact(int(r.direction.x)), fact(int(r.direction.y)), fact(int(r.direction.z)));
		res.weight = fact(int(r.weight));
		res.stokes = dvec4(fact(int(r.stokes.x)), fact(int(r.stokes.y)), fact(int(r.stokes.z)), fact(int(r.stokes[3])));
		res.energy = fact(int(r.energy));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 9) { // cosini (direction x,y,z from phi,psi)
		cosini(r, r.position.x, r.position.y); // inout ray (only direction important for function), phi, psi
		res.position = r.direction;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 10) { // test RayMatrixMult
		r = rayMatrixMult(r, quadricData[0].inTrans);
		res.position = r.position;
		res.direction = r.direction;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 11) { // wastebox
		double x = r.position.x;
		double z = r.position.z;
		double x_extent = r.direction.x;
		double z_extent = r.direction.z;
		double w = r.weight;
		res.position.x = wasteBox(x, z, x_extent, z_extent, w);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 12) { // test RZP line density
		dvec4 normal = dvec4(r.direction.x, r.direction.y, r.direction.z, 0);
		int image_type = int(quadricData[0].inTrans[0][0]);
		int rzp_type =  int(quadricData[0].inTrans[0][1]);
		int derivation_method = int(quadricData[0].inTrans[0][2]);
		double zOffsetCenter = quadricData[0].inTrans[0][3];
		double risag = quadricData[0].inTrans[1][0];
		double rosag = quadricData[0].inTrans[1][1];
		double rimer = quadricData[0].inTrans[1][2];
		double romer = quadricData[0].inTrans[1][3];
		double d_alpha = quadricData[0].inTrans[2][0];
		double d_beta = quadricData[0].inTrans[2][1];
		double d_ord = quadricData[0].inTrans[2][2];
		double wl = quadricData[0].inTrans[2][3];
		double DX;
		double DZ;
		RZPLineDensity(r, normal, image_type, rzp_type, derivation_method, zOffsetCenter,
			risag, rosag, rimer, romer, d_alpha, d_beta, d_ord, wl,
			DX, DZ);
		// write result to r.position to bring it back to the c++ unit test
		res.position.x = DX;
		res.position.z = DZ;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 13) {
		dvec4 normal = dvec4(r.direction,0);
		double slopeX = r.position.x;
		double slopeZ = r.position.z;
		dvec4 new_normal = normal_cartesian(normal, slopeX, slopeZ);
		res.position = dvec3(new_normal);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 14) {
		dvec4 normal = dvec4(r.direction,0);
		double slopeX = r.position.x;
		double slopeZ = r.position.z;
		dvec4 new_normal = normal_cylindrical(normal, slopeX, slopeZ);
		// normal is in homogeneous coordinates but ray direction and position are only interpreted as dvec3 on C++ side -> store fourth value in weight
		res.position = dvec3(new_normal);
		res.weight = new_normal[3];
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 15) {
		dvec4 normal = dvec4(r.position, 0);
		double a = r.energy;
		// only uses and  modifies ray.direction and weight -> use ray.position to transfer normal
		r = refrac(r, normal, a);
		res.direction = r.direction;
		res.weight = r.weight;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 16) {
		// Ray refrac2D(Ray r, dvec4 normal, double az, double ax)
		// refrac2D changes only the direction of the ray -> encode normal at intersection point in ray position
		dvec4 normal = dvec4(r.position, 0);
		double az = r.stokes.x;
		double ax = r.stokes.y;
		r = refrac2D(r, normal, az, ax);
		res.weight = r.weight;
		res.direction = r.direction;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 17) { // test uniform distribution
		res.weight = double(squares64RNG(ctr)) / double(uint64_t(0) - 1);
		res.energy = double(squares64RNG(ctr)) / double(uint64_t(0) - 1);
		res.position = dvec3(squaresDoubleRNG(ctr), squaresDoubleRNG(ctr),squaresDoubleRNG(ctr));
		res.direction = dvec3(squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		res.stokes = dvec4(squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr), squaresDoubleRNG(ctr));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 18) { // test exponential function
		res.weight = r8_exp(r.weight);
		res.energy = r8_exp(r.energy);
		res.position = dvec3(r8_exp(r.position.x), r8_exp(r.position.y), r8_exp(r.position.z));
		res.direction = dvec3(r8_exp(r.direction.x), r8_exp(r.direction.y), r8_exp(r.direction.z));
		res.stokes = dvec4(r8_exp(r.stokes.x), r8_exp(r.stokes.y), r8_exp(r.stokes.z), r8_exp(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 19) { // test logarithm function (natural logarithm)
		res.weight = r8_log(r.weight);
		res.energy = r8_log(r.energy);
		res.position = dvec3(r8_log(r.position.x), r8_log(r.position.y), r8_log(r.position.z));
		res.direction = dvec3(r8_log(r.direction.x), r8_log(r.direction.y), r8_log(r.direction.z));
		res.stokes = dvec4(r8_log(r.stokes.x), r8_log(r.stokes.y), r8_log(r.stokes.z), r8_log(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	else if(settings == 20) { // test iteratTo (method for finding intersection and normal for non-quadric surfaces like the torus)
		double longRadius = r.stokes.x;
		double shortRadius = r.stokes.y;
		dvec4 normal = iteratTo(r, longRadius, shortRadius);
		res.position = r.position;
		res.direction = r.direction; // normal?
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 21) { // test getIncidenceAngle function that is needed for the efficiency calculations
		res.position.x = getIncidenceAngle(r, dvec4(r.position,0));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 22) { // test reflectance function that calculates the s and p polarization
		double energy = r.energy;
		double incidence_angle = r.weight;
		dvec2 complex_S;
		dvec2 complex_P;
		reflectance(energy, incidence_angle, complex_S, complex_P, 0); // 0 == copper
		res.position.x = complex_S.x; // complex s polarisation
		res.position.y = complex_S.y;
		res.direction.x = complex_P.x; // complex p polarisation
		res.direction.y = complex_P.y;
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 23) { // test snell's law
		// all parameters are complex numbers -> dvec2
		dvec2 cos_incidence = dvec2(r.position.x, r.position.y); // cosinus of incidence angle of ray
		dvec2 cn1 = dvec2(r.direction.x, r.direction.y); // refractive index of first material
		dvec2 cn2 = dvec2(r.stokes.x, r.stokes.y); // refractive index of second material

		dvec2 cos_transmittance = snell(cos_incidence, cn1, cn2); // calculate cosinus of angle to normal of transmitted ray
		res.position = dvec3(cos_transmittance, 0);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 24) { // test fresnel formula
		// all parameters are complex numbers -> dvec2
		dvec2 cos_incidence = dvec2(r.position.x, r.position.y); // cosinus of incidence angle of ray
		dvec2 cos_transmittance = dvec2(r.direction.x, r.direction.y); // cosinus of transmittance angle (calc. by snell)
		dvec2 cn1 = dvec2(r.stokes.x, r.stokes.y); // refractive index of first material
		dvec2 cn2 = dvec2(r.stokes.z, r.stokes.w); // refractive index of second material
		dvec2 complex_S, complex_P;

		fresnel(cn1, cn2, cos_incidence, cos_transmittance, complex_S, complex_P);
		res.position = dvec3(complex_S, 0); // complex s polarisation
		res.direction = dvec3(complex_P, 0); // complex p polarisation
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 25) { // cartesian representation of complex number (x + y*i) to euler (r * e^(i*phi))
		dvec2 complex_cartesian1 = dvec2(r.position.x, r.position.y);
		dvec2 complex_cartesian2 = dvec2(r.direction.x, r.direction.y);
		dvec2 complex_cartesian3 = dvec2(r.stokes.x, r.stokes.y);
		dvec2 complex_cartesian4 = dvec2(r.stokes.z, r.stokes.w);

		dvec2 complex_euler1 = cartesian_to_euler(complex_cartesian1);
		dvec2 complex_euler2 = cartesian_to_euler(complex_cartesian2);
		dvec2 complex_euler3 = cartesian_to_euler(complex_cartesian3);
		dvec2 complex_euler4 = cartesian_to_euler(complex_cartesian4);
		res.position = dvec3(complex_euler1, 0);
		res.direction = dvec3(complex_euler2, 0);
		res.stokes = dvec4(complex_euler3, complex_euler4);
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 26) { // test material loading
		rayData[uint(gl_GlobalInvocationID)].position.x = nkp[0].energy;
		rayData[uint(gl_GlobalInvocationID)].position.y = nkp[0].n;
		rayData[uint(gl_GlobalInvocationID)].position.z = nkp[0].k;
		rayData[uint(gl_GlobalInvocationID)].weight = nkpIdx[0];

		rayData[uint(gl_GlobalInvocationID)].direction.x = nkp[nkpIdx[1]].energy;
		rayData[uint(gl_GlobalInvocationID)].direction.y = nkp[nkpIdx[1]].n;
		rayData[uint(gl_GlobalInvocationID)].direction.z = nkp[nkpIdx[1]].k;
		rayData[uint(gl_GlobalInvocationID)].energy = nkpIdx[1];
	}else if(settings == 27) { // TEST TRIG FUNCTIONS: cos
		res.position = dvec3(r8_cos(r.position.x), r8_cos(r.position.y),r8_cos(r.position.z));
		res.weight = r8_cos(r.weight);
		res.direction = dvec3(r8_cos(r.direction.x), r8_cos(r.direction.y), r8_cos(r.direction.z));
		res.energy = r8_cos(r.energy);
		res.stokes = dvec4(r8_cos(r.stokes[0]), r8_cos(r.stokes[1]), r8_cos(r.stokes[2]), r8_cos(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}else if(settings == 28) { // TEST TRIG FUNCTIONS: atan
		res.position = dvec3(r8_atan(r.position.x), r8_atan(r.position.y),r8_atan(r.position.z));
		res.weight = r8_atan(r.weight);
		res.direction = dvec3(r8_atan(r.direction.x), r8_atan(r.direction.y), r8_atan(r.direction.z));
		res.energy = r8_atan(r.energy);
		res.stokes = dvec4(r8_atan(r.stokes[0]), r8_atan(r.stokes[1]), r8_atan(r.stokes[2]), r8_atan(r.stokes[3]));
		rayData[uint(gl_GlobalInvocationID)] = res;
	}
	// store results to output buffer
	outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}

void main(){
    //dynamicElements();
	testFunctions();
	
	//output = input:
    //outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}
