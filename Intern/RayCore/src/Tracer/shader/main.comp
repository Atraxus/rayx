#define WORKGROUP_SIZE 32

#ifdef CPP
    #define INOUT(x) x&
    #define OUT(x) x&
    #define ALLOW_UNUSED [[maybe_unused]]
#else
    #define INOUT(x) inout x
    #define OUT(x) out x
    #define ALLOW_UNUSED

    #extension GL_EXT_debug_printf : enable
	#extension GL_ARB_separate_shader_objects : enable
	#extension GL_ARB_gpu_shader_int64 : enable
	#extension GL_GOOGLE_include_directive : enable

	layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
#endif

// Every shader execution calculates the route for a single ray.
// `_ray` is that ray, it's always in world coordinates (!).
#define _ray (rayData[uint(gl_GlobalInvocationID)])

#include "../../Constants.h"

/* STRUCTS */
// for CPP, the according things are mostly defined in CpuTracer.h
#ifdef CPP
int gl_GlobalInvocationID;

ShaderArray<Ray> rayData;
ShaderArray<Ray> outputData;

// the ray id of the first ray of the batch.
// See `rayId` to access the ray id of the current ray.
double rayIdStart;

// The total number of rays in this tracing process.
// (not only this batch)
double numRays;
double randomSeed;

// each ray will take multiple snapshots (copies) while tracing, those are then sent to the CPU for further processing.
double maxSnapshots;

ShaderArray<Element> quadricData;
ShaderArray<dvec4> xyznull;
ShaderArray<int> matIdx;
ShaderArray<double> mat;

#else
struct Ray {
    dvec3 m_position;
    // Initially weight for _ray is `W_IN_COMPUTATION`.
    // See the potential values of `m_weight` in `Constants.h`.
    double m_weight;
    dvec3 m_direction;
    double m_energy;
    dvec4 m_stokes;
    double m_pathLength;
    double m_order;
    double m_lastElement;
    double m_extraParam;
};
struct Element {
    dmat4 surfaceParams;
    dmat4 inTrans;
    dmat4 outTrans;
    dmat4 objectParameters;
    dmat4 elementParameters;
};

#ifdef RAYX_DEBUG_MODE
	struct _debug_struct {
		dmat4 _dMat; // Can also be used as vectors or scalar
	};
#endif

/* LAYOUTS */
    // don't use this directly. Use `_ray` instead.
	layout(std140, binding = 0) buffer ibuf { Ray rayData[]; };

    // don't use this directly. Use `takeSnapshot` instead.
	layout(std140, binding = 1) buffer obuf { Ray outputData[]; };

	layout(std140, binding = 2) buffer qbuf {
        double rayIdStart;
        double numRays;
        double randomSeed;
        double maxSnapshots;

		Element quadricData[];
	};

	layout(std140, binding = 3) buffer xyzbuf { dvec4 xyznull[]; };

	layout(binding = 4) buffer materialIndexBuf {
		int matIdx[]; // matIdx[0..91] contains the indices of the Palik Table, whereas matIdx[92..92+91] contains the indices of the NffTable.
					  // generally, an entry of matIdx tells you the index you need to look up in the 'mat'-table below.
	};

	layout(binding = 5) buffer materialBuf {
		double mat[];  // contains: (Palik tables of all materials concatenated together) concatenated with (Nff tables of all materials concatenated together)
					   // use the matIdx-table to determine the relevant indices for when which table starts and stops.
	};

	#ifdef RAYX_DEBUG_MODE
		layout(binding = 6) buffer debugBuf {
			_debug_struct d_struct[];  // contains nff table of all materials concatenated together
		};
	#endif


#endif

bool finalized;

// PushConstants 
#ifdef CPP
    pushConstants_t pushConstants;
#else 
    layout( push_constant ) uniform constants
    {
	    dmat4 pushMatrix;
    } PushConstants;
#endif

uint64_t rayId() {
    return uint64_t(rayIdStart) + uint64_t(gl_GlobalInvocationID);
}

// `i in [0, maxSnapshots]`.
// Will return the index in outputData to access the `i'th` output ray belonging to this shader call.
// Typically used as `outputData[output_index(i)]`.
uint output_index(uint i) {
    return uint(gl_GlobalInvocationID) * uint(maxSnapshots) + i;
}

// take a snapshot and store it in the next free spot in outputData.
// `r` will typically be _ray, or some related ray.
void takeSnapshot(Ray r, double w) {
    if (finalized) { return; }

    #ifdef CPP
    if (w == W_UNINIT) {
        RAYX_ERR << "takeSnapshot called with W_UNINIT";
    }
    #endif

    for (uint i = 0; i < maxSnapshots; i++) {
        uint idx = output_index(i);
        if (outputData[idx].m_weight == W_UNINIT) { // checks whether this spot is free
            outputData[idx] = r;
            outputData[idx].m_weight = w;
            return;
        }
    }

    // no spots were found.
    #ifdef CPP
    RAYX_WARN << "takeSnapshot failed: no free spots!";
    #endif
}

// like `takeSnapshot` above, but it will prevent taking more snapshots after this.
// Is used for snapshots terminating the path of the ray.
void takeFinalSnapshot(Ray r, double w) {
    takeSnapshot(r, w);
    finalized = true;
}


// Order in #include is IMPROTANT, do not change.
// clang-format off
#include "elements.comp"
#include "approx.comp"
#include "complex.comp"
#include "random.comp"
#include "utils.comp"
#include "intersection.comp"
#include "trace.comp"
#include "dynamic_elements.comp"
// clang-format on

// sets all output rays controlled by this shader call to W_UNINIT.
void uninitRays() {
    for (uint i = 0; i < maxSnapshots; i++) {
        outputData[output_index(i)].m_weight = W_UNINIT;
    }
}

void main() {
    finalized = false;
    uninitRays();

    // Printing ~DEBUG~ Example over vkconfig Validation Layers
    // if (uint(gl_GlobalInvocationID) == 2 ){
    // #ifndef CPP
    //     // debugPrintfEXT("Hello from GPU. \n");
    // #else
    //     // RAYX_D_LOG << "Tracing on CPU..." ;
    //     // RAYX_D_LOG << pushConstants.pushMatrix[0][0];
    // #endif
    // }
	dynamicElements();
}
