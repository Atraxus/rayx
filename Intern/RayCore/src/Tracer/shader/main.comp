#define WORKGROUP_SIZE 32

#ifdef CPP
    #define INOUT(x) x&
    #define OUT(x) x&
    #define ALLOW_UNUSED [[maybe_unused]]
#else
    #define INOUT(x) inout x
    #define OUT(x) out x
    #define ALLOW_UNUSED

    #extension GL_EXT_debug_printf : enable
	#extension GL_ARB_separate_shader_objects : enable
	#extension GL_ARB_gpu_shader_int64 : enable
	#extension GL_GOOGLE_include_directive : enable

	layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
#endif

// Every shader execution calculates the route for a single ray.
// `_ray` is that ray, it's always in world coordinates (!).
#define _ray (rayData[uint(gl_GlobalInvocationID)])
// The resulting ray will be written to `_out`.
// It will have some `m_weight` other than `W_IN_COMPUTATION`.
// The coordinate system of `_out` depends on `m_weight`, see the definition below.
#define _out (outputData[uint(gl_GlobalInvocationID)])

#include "../../Constants.h"
const uint64_t rngKey = 13; // TODO(rudi) this was the old key, it generated a warning: (0xc8e4fd15 << 32) | 0x4ce32f6d;

/* The meaning of the `m_weight` field of a `Ray` { */
    // The future Path of this Ray does not intersect any elements anymore (in other words `getOpticalElementIntersection` yields w=0 for all elements)
    // This Ray now flies off to infinity.
    //
    // Ray is in world coordinates.
    const double W_FLY_OFF = 0;

    // This Ray is still pathing through objects.
    // When the computation is finished weight shall not be `W_IN_COMPUTATION`.
    //
    // Ray is in world coordinates.
    const double W_IN_COMPUTATION = 1;

    // This Ray has hit an ImagePlane, this ImagePlane is `m_lastElement`.
    //
    // Ray is in element coordinates, relative to `m_lastElement`.
    const double W_HIT_IMAGE_PLANE = 2;

    // This Ray was absorbed by `m_lastElement`.
    //
    // Ray is in element coordinates, relative to `m_lastElement`.
    // TODO not yet used!
    const double W_ABSORBED = 3;
/* } */

/* STRUCTS */
// for CPP, the according things are mostly defined in CpuTracer.h
#ifdef CPP
int gl_GlobalInvocationID;

ShaderArray<Ray> rayData;
ShaderArray<Ray> outputData;
double numberOfBeamlines;
double numberOfElementsPerBeamline;
double numberOfRays;
double numberOfRaysPerBeamLine;
ShaderArray<Element> quadricData;
ShaderArray<dvec4> xyznull;
ShaderArray<int> matIdx;
ShaderArray<double> mat;

#else
struct Ray {
    dvec3 m_position;
    // Initially weight is `W_IN_COMPUTATION`.
    // See the potential values of `m_weight` above.
    double m_weight;
    dvec3 m_direction;
    double m_energy;
    dvec4 m_stokes;
    double m_pathLength;
    double m_order;
    double m_lastElement;
    double m_extraParam;
};
struct Element {
    dmat4 surfaceParams;
    dmat4 inTrans;
    dmat4 outTrans;
    dmat4 objectParameters;
    dmat4 elementParameters;
};

#ifdef RAYX_DEBUG_MODE
	struct _debug_struct {
		dmat4 _dMat; // Can also be used as vectors or scalar
	};
#endif
/* LAYOUTS */
    // don't use this directly. Use `_ray` instead.
	layout(std140, binding = 0) buffer ibuf { Ray rayData[]; };

    // don't use this directly. Use `_out` instead.
	layout(std140, binding = 1) buffer obuf { Ray outputData[]; };

	layout(std140, binding = 2) buffer qbuf {
		double numberOfBeamlines;
		double numberOfElementsPerBeamline;
		double numberOfRays;
		double numberOfRaysPerBeamLine;
		Element quadricData[];
	};

	layout(std140, binding = 3) buffer xyzbuf { dvec4 xyznull[]; };

	layout(binding = 4) buffer materialIndexBuf {
		int matIdx[]; // matIdx[0..91] contains the indices of the Palik Table, whereas matIdx[92..92+91] contains the indices of the NffTable.
					  // generally, an entry of matIdx tells you the index you need to look up in the 'mat'-table below.
	};

	layout(binding = 5) buffer materialBuf {
		double mat[];  // contains: (Palik tables of all materials concatenated together) concatenated with (Nff tables of all materials concatenated together)
					   // use the matIdx-table to determine the relevant indices for when which table starts and stops.
	};

	#ifdef RAYX_DEBUG_MODE
		layout(binding = 6) buffer debugBuf {
			_debug_struct d_struct[];  // contains nff table of all materials concatenated together
		};
	#endif
#endif

// Order in #include is IMPROTANT, do not change.
// clang-format off
#include "approx.comp"
#include "complex.comp"
#include "random.comp"
#include "utils.comp"
#include "intersection.comp"
#include "trace.comp"
#include "dynamic_elements.comp"
// clang-format on

void main() {
	dynamicElements();

    // output = input:
    // _out = _ray;
}
