#define WORKGROUP_SIZE 32

#ifdef CPP
    #define INOUT(x) x&
    #define OUT(x) x&
    #define ALLOW_UNUSED [[maybe_unused]]
#else
    #define INOUT(x) inout x
    #define OUT(x) out x
    #define ALLOW_UNUSED

    #extension GL_EXT_debug_printf : enable
	#extension GL_ARB_separate_shader_objects : enable
	#extension GL_ARB_gpu_shader_int64 : enable
	#extension GL_GOOGLE_include_directive : enable

	layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
#endif

// Every shader execution calculates the route for a single ray.
// `_ray` is that ray. The output will be written to `_out`.
#define _ray (rayData[uint(gl_GlobalInvocationID)])
#define _out (outputData[uint(gl_GlobalInvocationID)])

#include "../../Constants.h"
const uint64_t rngKey = 13; // TODO(rudi) this was the old key, it generated a warning: (0xc8e4fd15 << 32) | 0x4ce32f6d;

/* The meaning of the `m_weight` field of a `Ray` { */
    // The future Path of this Ray does not intersect any elements anymore (in other words `getOpticalElementIntersection` yields w=0 for all elements)
    // This Ray now flies off to infinity.
    // position & orientation are in world coordinates.
    const double W_FLY_OFF = 0;

    // This Ray is still pathing through objects.
    // When the computation is finished weight shall not be `W_IN_COMPUTATION`.
    // position & orientation might be in world or element coordinates, depending on the segment of the computation.
    const double W_IN_COMPUTATION = 1;

    // This Ray has hit an ImagePlane, this ImagePlane is `m_lastElement`.
    // position & orientation are in element coordinates, relative to `m_lastElement`.
    const double W_HIT_IMAGE_PLANE = 2;

    // This Ray was absorbed by `m_lastElement`.
    // position & orientation are in element coordinates, relative to `m_lastElement`.
    const double W_ABSORBED = 3;
/* } */

/* STRUCTS */
// for CPP, the according things are mostly defined in CpuTracer.h
#ifdef CPP
int gl_GlobalInvocationID;

ShaderArray<Ray> rayData;
ShaderArray<Ray> outputData;
double numberOfBeamlines;
double numberOfElementsPerBeamline;
double numberOfRays;
double numberOfRaysPerBeamLine;
ShaderArray<Element> quadricData;
ShaderArray<dvec4> xyznull;
ShaderArray<int> matIdx;
ShaderArray<double> mat;

#else
struct Ray {
    dvec3 m_position;
    // Initially weight is `W_IN_COMPUTATION`.
    // See the potential values of `m_weight` above.
    double m_weight;
    dvec3 m_direction;
    double m_energy;
    dvec4 m_stokes;
    double m_pathLength;
    double m_order;
    double m_lastElement;
    double m_extraParam;
};
struct Element {
    dmat4 surfaceParams;
    dmat4 inTrans;
    dmat4 outTrans;
    dmat4 objectParameters;
    dmat4 elementParameters;
};

#ifdef RAYX_DEBUG_MODE
	struct _debug_struct {
		dmat4 _dMat; // Can also be used as vectors or scalar
	};
#endif
/* LAYOUTS */
	layout(std140, binding = 0) buffer ibuf { Ray rayData[]; }; // in global coordinates

	layout(std140, binding = 1) buffer obuf { Ray outputData[]; }; // in element coordinates, i.e. relative to the last element the ray has collided with.

	layout(std140, binding = 2) buffer qbuf {
		double numberOfBeamlines;
		double numberOfElementsPerBeamline;
		double numberOfRays;
		double numberOfRaysPerBeamLine;
		Element quadricData[];
	};

	layout(std140, binding = 3) buffer xyzbuf { dvec4 xyznull[]; };

	layout(binding = 4) buffer materialIndexBuf {
		int matIdx[]; // matIdx[0..91] contains the indices of the Palik Table, whereas matIdx[92..92+91] contains the indices of the NffTable.
					  // generally, an entry of matIdx tells you the index you need to look up in the 'mat'-table below.
	};

	layout(binding = 5) buffer materialBuf {
		double mat[];  // contains: (Palik tables of all materials concatenated together) concatenated with (Nff tables of all materials concatenated together)
					   // use the matIdx-table to determine the relevant indices for when which table starts and stops.
	};

	#ifdef RAYX_DEBUG_MODE
		layout(binding = 6) buffer debugBuf {
			_debug_struct d_struct[];  // contains nff table of all materials concatenated together
		};
	#endif
#endif

// Order in #include is IMPROTANT, do not change.
// clang-format off
#include "approx.comp"
#include "complex.comp"
#include "random.comp"
#include "utils.comp"
#include "intersection.comp"
#include "trace.comp"
// clang-format on

// @brief: Dynamic ray tracing: check which ray hits which element first
// in this function we need to make sure that rayData ALWAYS remains in GLOBAL coordinates (it can be changed in a function but needs to be changed
// back before the function returns to this function)
void dynamicElements() {
    const int numberOfElements = quadricData.length();
    // placeholder, info should later be transfered to shader
    const int maxBounces  = numberOfElements;
    uint beamlineIndex    = uint(double(gl_GlobalInvocationID) / numberOfRaysPerBeamLine);

    // ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random number
    uint64_t workerCounterNum = (~(uint64_t(0)) / int(numberOfRays));
    uint64_t ctr              = uint(gl_GlobalInvocationID) * workerCounterNum;
    int type                  = -1;

    int closestElementIndex = -1;
    dvec4 closestHitpoint = dvec4(infinity(), infinity(), infinity(), 0.0);
    dvec4 closestGlobalHitpoint;

    #ifdef RAYX_DEBUG_MODE // Debug Matrix only works in GPU Mode and on DEBUG Build Type
    #ifndef CPP
    // Set Debug Struct of current Ray to identity
    d_struct[uint(gl_GlobalInvocationID)]._dMat = dmat4(1);
    #endif
    #endif

    Element nextElement;
    // at the end of this function we apply inTrans, if no collision happened (i.e. nextElement undefined), we want this to do nothing.
    nextElement.inTrans = dmat4(1);
    nextElement.outTrans = dmat4(1);

    double bounce = 1;

    // Printing Example over vkconfig Validation Layers
    if (uint(gl_GlobalInvocationID) == 2 ){
    #ifndef CPP
        // debugPrintfEXT("Hello from GPU. \n");
    #else
        // RAYX_D_LOG << "Tracing on CPU..." ;
    #endif
    }

    // Iterate through all bounces
    for (int i = 0; i < maxBounces; i++) {
        // index of element with current closest intersection with ray, initialized with -1
        closestElementIndex = -1;

        // global coordinates of first intersection point of ray among all elements in beamline
        closestHitpoint       = dvec4(infinity(), infinity(), infinity(), 0);
        closestGlobalHitpoint = dvec4(infinity(), infinity(), infinity(), 0);

        // Find intersection points through all elements
        for (int elementIndex = int(beamlineIndex) * int(numberOfElementsPerBeamline);
             elementIndex < (beamlineIndex + 1) * numberOfElementsPerBeamline; elementIndex++) {

            double lastElement = _ray.m_lastElement;
            if (elementIndex + 1 == lastElement) {
                // TODO: self-intersection
                // _ray.m_weight = 11;
                continue;
            }

            dvec4 currentIntersection = getOpticalElementIntersection(_ray, elementIndex);
            dvec3 currentIntersection_xyz = dvec3(currentIntersection.x, currentIntersection.y, currentIntersection.z);

            // Intersection coordinates in GLOBAL coordinates
            dvec4 currentGlobalIntersection;
            dvec3 tmp = dvec3(quadricData[elementIndex].outTrans * dvec4(currentIntersection_xyz, 1));
            currentGlobalIntersection = dvec4(tmp, currentGlobalIntersection.w);
            dvec3 currentGlobalIntersection_xyz = dvec3(currentGlobalIntersection.x, currentGlobalIntersection.y, currentGlobalIntersection.z);

            dvec3 closestGlobalHitpoint_xyz = dvec3(closestGlobalHitpoint.x, closestGlobalHitpoint.y, closestGlobalHitpoint.z);
            // check if current intersection is closer than the closest previous Hitpoint
            // If yes then update. Since the old intersection is occluded by the old Intersection/Hit point
            if (length(_ray.m_position - closestGlobalHitpoint_xyz) > length(_ray.m_position - currentGlobalIntersection_xyz) &&
                currentIntersection.w != 0) {
                closestHitpoint       = currentIntersection;
                closestGlobalHitpoint = currentGlobalIntersection;
                closestElementIndex   = elementIndex;
            }
        }

        if (closestElementIndex == -1) {  // no element was hit. Ray is considered to move forward to inf.
            _ray.m_weight = W_FLY_OFF;
            break;
        }

        // transform ray and intersection point in ELEMENT coordiantes
        nextElement                          = quadricData[closestElementIndex];
        _ray = rayMatrixMult(_ray, nextElement.inTrans);

        // Calculate interaction(reflection,material, absorption etc.) of ray with detected next element
        type = int(nextElement.surfaceParams[3][0]);
        if (type == 0) {  // plane + sphere mirror
            _ray = traceMirror(_ray, closestElementIndex, ctr, closestHitpoint);

        } else if (type == 1) {  // plane grating
            _ray = tracePlaneGrating(_ray, closestElementIndex, ctr, closestHitpoint);

        } else if (type == 2) {  // general grating
            _ray = traceGeneralGrating(_ray, closestElementIndex, ctr, closestHitpoint);

        } else if (type == 3) {  // Slit
            _ray = traceSlit(_ray, closestElementIndex, ctr, closestHitpoint);

        } else if (type == 4) {  // rzp
            _ray = traceRZP(_ray, closestElementIndex, ctr, closestHitpoint);

        } else if (type == 5) {  // image plane
            _ray.m_extraParam += (closestElementIndex + 1) * bounce;
            _ray.m_lastElement = closestElementIndex + 1;
            _ray.m_weight = W_HIT_IMAGE_PLANE;
            _out = traceImagePlane(_ray, closestElementIndex, closestHitpoint);
            return;

        } else if (type == 6) {  // toroid mirror
            _ray = traceToroid(_ray, closestElementIndex, ctr, closestHitpoint);

        } else if (type == 7) {  // ellipsoid mirror
            _ray = traceEllipsoidMirror(_ray, closestElementIndex, ctr, closestHitpoint);
        }

        // use extraParameter to store the order in which the ray has hit which optical element (e.g extraParameter = 412 -> first hit element 2, then
        // 1, then 4)
        _ray.m_extraParam += ((closestElementIndex + 1) * bounce) * int(_ray.m_lastElement == closestElementIndex + 1);
        bounce *= pow(10, int(_ray.m_lastElement == closestElementIndex + 1));

        // transform back to WORLD coordinates
        _ray = rayMatrixMult(_ray, nextElement.outTrans);
    }

    // outputData should be in element coordinates.
    _out = rayMatrixMult(_ray, nextElement.inTrans);
}

void main() {
	dynamicElements();

    // output = input:
    // _out = _ray;
}
