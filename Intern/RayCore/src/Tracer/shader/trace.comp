/// Each `trace*` function gets a `Ray r` (in element-coords), the element itself, a randomness counter and the `Collision col`.
/// `col.hitpoint` expresses where the given ray r will hit the element (in element-coords).
/// `col.normal` expresses the normal of the surface, at `col.hitpoint` (in element-coords).
///
/// The `trace*` functions, will
/// - change the rays direction, typically by reflecting using the normal
/// - change the rays stokes vector
/// - potentially absorb the ray (by calling `takeFinalSnapshot(_, W_ABSORBED)`)
// TODO(rudi) all of the following things could be done before calling the `trace*` function, it's the same everywhere, I think.
/// - move the ray to the `col.hitpoint`
/// - update the rays `lastElement`
/// - increase the rays `pathLength`

Ray traceSlit(Ray r, Slit slit, INOUT(uint64_t) ctr, Collision col) {
    // store old position, needed for pathlength calculation
    dvec3 old_position = r.m_position;

    // dvec4 normal = intersectionPoint(r, q.surfaceParams); // if it is not sure whether the given intersection is correct, use this (recalculate the
    // intersection)
    r.m_position = col.hitpoint;

    // add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do
    // not need to transform back to world coordinates??)
    r.m_pathLength += length(old_position - r.m_position);
    r.m_lastElement = slit.id + 1;

    double x_extent = width(slit);
    double y_extent = height(slit);
    double xStop    = beamstopWidth(slit);
    double yStop    = beamstopHeight(slit);

    // slit lies in x-y plane instead of x-z plane as other elements
    bool withinSlitBounds = wasteBox(r.m_position[0], r.m_position[1], x_extent, y_extent);
    bool outsideOfBeamstop = stopBox(r.m_position[0], r.m_position[1], xStop, yStop);

    if (!withinSlitBounds || !outsideOfBeamstop) {
        takeFinalSnapshot(r, W_ABSORBED);
        return r;
    }

    double psi        = -r8_asin(r.m_direction.y);
    double phi        = r8_asin(r.m_direction.x / r8_cos(psi));
    double delPhi     = 0;
    double delPsi     = 0;
    int iopt          = 1;                             // 1 = slit, 3 = zone plate
    double wavelength = hvlam(r.m_energy);
    diffraction(iopt, x_extent, y_extent, wavelength, delPhi, delPsi, ctr);
    phi = phi + delPhi;
    psi = psi + delPsi;

    // new direction from angles
    cosini(r, phi, psi);

    r.m_order = 0;
    return r;
}

Ray traceRZP(Ray r, Rzp rzp, INOUT(uint64_t) ctr, Collision col) {
    double element_offset_z = elementOffsetZ(rzp);
    r.m_position.z            = r.m_position.z - element_offset_z;

    // store old position, needed for pathlength calculation
    dvec3 old_position = r.m_position;

    dvec4 normal = dvec4(col.normal, 0);
    r.m_position = col.hitpoint;

    // add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do
    // not need to transform back to world coordinates??)
    r.m_pathLength += length(old_position - r.m_position);
    r.m_lastElement = rzp.id + 1;

    dmat4 e = elementParams(rzp);
    int IMAGE_TYPE        = int(e[0][0]);
    int RZP_TYPE          = int(e[0][1]);
    int DERIVATION_METHOD = int(e[0][2]);
    double risag          = e[2][0];
    double rosag          = e[2][1];
    double rimer          = e[2][2];
    double romer          = e[2][3];
    double d_alpha        = e[3][0];
    double d_beta         = e[3][1];
    double d_ord          = e[1][1];
    double zOffsetCenter  = e[1][3];
    ;  // fresnel center z offset
    double WL            = hvlam(r.m_energy);
    double WL0           = 1e-06 * e[0][3];  // source energy/design energy
    double Ord           = e[1][2];
    int additional_order = int(e[3][3]);

    // calculate the RZP line density for the position of the intersection on the RZP
    double DX, DZ;
    RZPLineDensity(r, normal, IMAGE_TYPE, RZP_TYPE, DERIVATION_METHOD, zOffsetCenter, risag, rosag, rimer, romer, d_alpha, d_beta, d_ord, WL0, DX,
                   DZ);

    // tanger/slope Error
    normal        = tanger(normal, slopeX(rzp), slopeZ(rzp), 0, ctr);

    // if additional zero order should be traced, approx. half of the rays are randomly chosen to be traced in order 0 (= ordinary reflection) instead
    // of the given order
    if (additional_order == 1) {
        if (squaresDoubleRNG(ctr) > 0.5) Ord = 0;
    }

    // only 2D case, not 2 1D gratings with 90 degree rotation as in old RAY
    double az = WL * DZ * Ord * 1e-6;
    double ax = WL * DX * Ord * 1e-6;
    r         = refrac2D(r, normal, az, ax);

    if (r.m_weight == W_BEYOND_HORIZON) {
        takeFinalSnapshot(r, W_BEYOND_HORIZON);
    }

    r.m_order   = Ord;

    r.m_position.z += element_offset_z;
    return r;
}

Ray traceGrating(Ray r, Grating gg, INOUT(uint64_t) ctr, Collision col) {
    // store old position, needed for pathlength calculation
    dvec3 old_position = r.m_position;

    dvec4 normal = dvec4(col.normal, 0);
    r.m_position = col.hitpoint;
    // normal = normalize(dvec4(-r.m_position.x, -radius - r.m_position[1]*ISIG, -r.m_position[2], 0));

    // add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do
    // not need to transform back to world coordinates??)
    r.m_pathLength += length(old_position - r.m_position);
    r.m_lastElement = gg.id + 1;

    // modify normal according to slope error
    normal        = tanger(normal, slopeX(gg), slopeZ(gg), 0, ctr);

    // vls parameters passed in q.elementParams
    dmat4 e = elementParams(gg);
    double WL                 = hvlam(r.m_energy);
    double lineDensity        = e[0][2];
    double orderOfDiffraction = e[0][3];
    double b_params[6] = {e[1][2], e[1][3], e[2][0], e[2][1], e[2][2], e[2][3]};

    // linedensity = WL * default_linedensity * order * 1e-06
    double linedensity = vlsGrating(lineDensity, r.m_position.z, b_params) * WL * orderOfDiffraction * 1e-06;
    r.m_order            = orderOfDiffraction;
    // no additional zero order here?

    // refraction
    r = refrac(r, normal, linedensity);

    if (r.m_weight == W_BEYOND_HORIZON) {
        takeFinalSnapshot(r, W_BEYOND_HORIZON);
    }

    return r;
}

Ray traceMirror(Ray r, Mirror m, INOUT(uint64_t) ctr, Collision col) {
    // store old position, needed for pathlength calculation
    dvec3 old_position = r.m_position;

    // calculate intersection point and normal at intersection point
    dvec4 normal = dvec4(col.normal, 0);
    r.m_position = col.hitpoint;
    double azimuthal_angle = azimuthalAngle(m);

    // add the travelled distance from the previous position to the new intersection to pathlength (both are in the same coordinate system so we do
    // not need to transform back to world coordinates??)
    r.m_pathLength += length(old_position - r.m_position);
    r.m_lastElement = m.id + 1;

    // take the slope error into account for the normal
    normal = tanger(normal, slopeX(m), slopeZ(m), 0, ctr);  // option 0 = default, cartesian normal

    // calculate the new direction after the reflection
    r.m_direction = dvec3(reflect(dvec4(r.m_direction, 0), normal));

    double real_S, real_P, delta;
    double incidence_angle = getIncidenceAngle(r, normal);  // getTheta
    int mat = int(material(m));
    if (mat != -2) {
        efficiency(r, real_S, real_P, delta, incidence_angle, mat);

        bool absorbed = update_stokes(r, real_S, real_P, delta, azimuthal_angle, ctr);
        if (absorbed) {
            takeFinalSnapshot(r, W_ABSORBED);
        }
        r.m_order = 0;
    }
    return r;
}

Ray traceImagePlane(Ray r, ALLOW_UNUSED ImagePlane ip, Collision col) {
    // path length in element coordinates
    r.m_pathLength += length(r.m_position - col.hitpoint);
    r.m_position = col.hitpoint;
    r.m_lastElement = ip.id + 1;
    return r;
}
