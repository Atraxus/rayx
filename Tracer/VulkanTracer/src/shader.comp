#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

struct Ray{
	dvec3 position;
	double weight; // status of the ray (e.g if element missed -> 0)
	dvec4 direction;
};
struct Quadric{
	dmat4 anchorPoints;
	dmat4 inTrans;
	dmat4 outTrans;
	dmat4 misalignment;
	dmat4 inverseMisalignment;
};
layout(std140, binding = 0) buffer ibuf
{
   Ray rayData[];
};

layout(std140, binding = 1) buffer obuf
{
   Ray outputData[];
};
layout(std140, binding = 2) buffer qbuf
{
	Quadric quadricData[];
};

// DOUBLE PREC TRIGONOMETRIC FUNCTIONS USING MINIMAX APPROXIMATION

/**
* sin approximation
* error < 2e-11
* source: https://outerra.blogspot.com/2017/06/fp64-approximations-for-sincos-for.html
*/
double sina_11(double x)
{
    //minimax coefs for sin for 0..pi/2 range
    const double a3 = -1.666666660646699151540776973346659104119e-1LF;
    const double a5 =  8.333330495671426021718370503012583606364e-3LF;
    const double a7 = -1.984080403919620610590106573736892971297e-4LF;
    const double a9 =  2.752261885409148183683678902130857814965e-6LF;
    const double ab = -2.384669400943475552559273983214582409441e-8LF;

    const double m_2_pi = 0.636619772367581343076LF;
    const double m_pi_2 = 1.57079632679489661923LF;

    double y = abs(x * m_2_pi);
    double q = floor(y);
    int quadrant = int(q);

    double t = (quadrant & 1) != 0 ? 1 - y + q : y - q;
    t *= m_pi_2;

    double t2 = t * t;
    double r = fma(fma(fma(fma(fma(ab, t2, a9), t2, a7), t2, a5), t2, a3),
        t2*t, t);

    r = x < 0 ? -r : r;

    return (quadrant & 2) != 0 ? -r : r;
}

/** cos approximation, error < 2e-11
* uses sina_11 with shifted input (+pi/2)
*/
double cosa_11(double x)
{
    //sin(x + PI/2) = cos(x)
    return sina_11(x + 1.57079632679489661923LF);
}

/**
* atan2 approximation
* error < 5e-9
* source: 
* https://outerra.blogspot.com/2014/05/double-precision-approximations-for-map.html
*/
double arctan2(double y, double x)
{
    const double atan_tbl[] = {
    -3.333333333333333333333333333303396520128e-1LF,
     1.999999117496509842004185053319506031014e-1LF,
    -1.428514132711481940637283859690014415584e-1LF,
     1.110012236849539584126568416131750076191e-1LF,
    -8.993611617787817334566922323958104463948e-2LF,
     7.212338962134411520637759523226823838487e-2LF,
    -5.205055255952184339031830383744136009889e-2LF,
     2.938542391751121307313459297120064977888e-2LF,
    -1.079891788348568421355096111489189625479e-2LF,
     1.858552116405489677124095112269935093498e-3LF
    };

    /* argument reduction: 
       arctan (-x) = -arctan(x); 
       arctan (1/x) = 1/2 * pi - arctan (x), when x > 0
    */

    double ax = abs(x);
    double ay = abs(y);
    double t0 = max(ax, ay);
    double t1 = min(ax, ay);
    
    double a = 1 / t0;
    a *= t1;

    double s = a * a;
    double p = atan_tbl[9];

    p = fma( fma( fma( fma( fma( fma( fma( fma( fma( fma(p, s,
        atan_tbl[8]), s,
        atan_tbl[7]), s, 
        atan_tbl[6]), s,
        atan_tbl[5]), s,
        atan_tbl[4]), s,
        atan_tbl[3]), s,
        atan_tbl[2]), s,
        atan_tbl[1]), s,
        atan_tbl[0]), s*a, a);

    double r = ay > ax ? (1.57079632679489661923LF - p) : p;

    r = x < 0 ?  3.14159265358979323846LF - r : r;
    r = y < 0 ? -r : r;

    return r;
}

/* HERE STARTS RAY TRACING CODE */



/**
* checks whether the intersection point is within the extent of the surface
* @param x, z			 	x- and z-coordinates of the intersection point
* @param xLength, zLength	width and length of the optical element
* @param w 					current weight of the ray
*
* returns: unchanged weight if intersection point is within surface boundaries, 0.0 if not.
*/
double wasteBox(double x, double z, double xLength, double zLength, double w) 
{
	double x_min = -xLength/2.0;
	double x_max = xLength/2.0;
	double z_min = -zLength/2.0;
	double z_max = zLength/2.0;

	if (xLength >= 0){ // Rectangular shape
		if (x <= x_min || x >= x_max || z <= z_min || z >= z_max) {
			return 0.0;
		}
	}else{	// Ring shape
		double rd2 = (x/(xLength/2.0)) * (x/(xLength/2.0)) + (z/(zLength/2.0))*(z/(zLength/2.0));
		if (rd2 > 1.0) {
			return 0.0;
		}
	} 
	return w;
}

/**
* calculates the intersection point of a ray with a quadric surface defined by a_11..a_44
* @param r				ray for which the intersection is fount
* @param a_11..a_44		define the quadric surface
* @param icurv 			defines whether the first or the second intersection is used (1=first, -1=second)
*
* output: reflected Ray with intersection point as position and reflection as direction
*/
dvec4 intersectionPoint(inout Ray r, dmat4 quadric, int icurv)
{	
	double a_11 = quadric[0][0];
	double a_12 = quadric[0][1];
	double a_13 = quadric[0][2];
	double a_14 = quadric[0][3];
	double a_22 = quadric[1][1];
	double a_23 = quadric[1][2];
	double a_24 = quadric[1][3];
	double a_33 = quadric[2][2];
	double a_34 = quadric[2][3];
	double a_44 = quadric[3][3];
	
	Ray outputR;
	outputR.position = r.position;
	outputR.direction =  dvec4(a_11,a_22,a_33,a_24);
	outputR.weight = 0;

	double w = r.weight;
	int cs = 1;
	int sign = icurv;
	if (abs(r.direction[1]) >= abs(r.direction[0]) && abs(r.direction[1]) >= abs(r.direction[2])) {
		cs = 2;
	}else if (abs(r.direction[2]) >= abs(r.direction[0]) && abs(r.direction[2]) >= abs(r.direction[1])) {
		cs = 3;
	}
	
	double x;
	double y;
	double z;
		
	if (cs == 1) {
		double aml = r.direction[1] / r.direction[0];
		double anl = r.direction[2] / r.direction[0];
		y = r.position[1] - aml * r.position[0];
		z = r.position[2] - anl * r.position[0];
		if (r.direction[0] < 0) {
			sign = -icurv;
		}
		
		double a = a_11 + 2*a_12*aml + a_22*aml*aml + 2*a_13*anl + 2*a_23*aml*anl + a_33*anl*anl;
        double b = a_14 + a_24*aml + a_34*anl + (a_12 + a_22*aml + a_23*anl)*y + (a_13 + a_23*aml + a_33*anl)*z;
        double c = a_44 + a_22*y*y + 2*a_34*z + a_33*z*z + 2*y*(a_24 + a_23*z);
		
		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0; 	// oder -4?
			x = - y/aml; 	// x such that y=0
		}else{
			if (abs(a) > pow(float(abs(c)*10), float(-10))) {
				x = (-b + sign*sqrt(bbac)) / a;
			}else{
				x = (-c/2)/b;
			}
		}
		y = y + aml*x;
		z = z + anl*x;
		
	}else if (cs == 2) {
		double alm = r.direction[0] / r.direction[1];
		double anm = r.direction[2] / r.direction[1];
		x = r.position[0] - alm * r.position[1];
		z = r.position[2] - anm * r.position[1];
		if(r.direction[1] < 0) {
			sign = -icurv;
		}
		
		double a = a_22 + 2*a_12*alm + a_11*alm*alm + 2*a_23*anm + 2*a_13*alm*anm + a_33*anm*anm;
        double b = a_24 + a_14*alm + a_34*anm + (a_12 + a_11*alm + a_13*anm)*x + (a_23 + a_13*alm + a_33*anm)*z;
        double c = a_44 + a_11*x*x + 2*a_34*z + a_33*z*z + x*(2*a_14 + 2*a_13*z);
		
		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			y = 0;
		}else{
			if (abs(a) > pow(float(abs(c)*10), float(-10))) {
				y = (-b + sign*sqrt(bbac)) / a;
			}else{
				y = (-c/2)/b;
			}
		}
		x = x + alm*y;
		z = z + anm*y;
	}else{
		double aln = r.direction[0] / r.direction[2];
		double amn = r.direction[1] / r.direction[2];
		x = r.position[0] - aln * r.position[2];
		y = r.position[1] - amn * r.position[2];
		if(r.direction[2] < 0) {
			sign = -icurv;
		}
		
		double a = a_33 + 2*a_13*aln + a_11*aln*aln + 2*a_23*amn + 2*a_12*aln*amn + a_22*amn*amn;
        double b = a_34 + a_14*aln + a_24*amn + (a_13 + a_11*aln + a_12*amn)*x + (a_23 + a_12*aln + a_22*amn)*y;
        double c = a_44 + a_11*x*x + 2*a_24*y + a_22*y*y + x*(2*a_14 + 2*a_12*y);
		
		double bbac = b*b - a*c;
		if (bbac < 0) {
			w = 0.0;
			z = -y / amn;
		}else{
			if (abs(a) > abs(c)*pow(10, double(-10))) {
				z = (-b + sign*sqrt(bbac)) / a;
			}else{
				z = (-c/2)/b;
			}
		}
		x = x + aln*z;
		y = y + amn*z;
	}
	
	double fx = 2*a_14 + 2*a_11*x + 2*a_12*y + 2*a_13*z;
	double fy = 2*a_24 + 2*a_12*x + 2*a_22*y + 2*a_23*z;
    double fz = 2*a_34 + 2*a_13*x + 2*a_23*y + 2*a_33*z;
	
	dvec4 normal = normalize(dvec4(fx,fy,fz,0));
	r.position = dvec3(x,y,z); // new position = intersection point
	r.weight = w; // unchanged, if ray did not miss surface, else 0
	return normal;
}

// refraction function used for gratings
Ray refrac(Ray r, dvec4 normal, double a){
	double xy = normal[0] / normal[1];
	double zy = normal[2] / normal[1];
	double sqq = sqrt(1 + zy*zy + xy*xy);
	double an_x = xy/sqq;
	double an_y = -1.0/sqq;
	double an_z = zy/sqq;
	
	// oft 0, mit if bed. checken?
	double eps1 = arctan2(an_x, an_y); //-atan(an_x/an_z) around z, chi
	double del1 = 2 * arctan2(an_z, 1+sqrt(1-an_z*an_z)); // -asin(an_z); // -asin around x, psi
	
	double cos_d = cosa_11(del1);
	double sin_d = sina_11(del1);
	double cos_e = cosa_11(eps1);
	double sin_e = sina_11(eps1);
	double a1;
	if(eps1 == 0) {
		a1 = 1.0;
	}else{
		a1  = a*cos_e; // cos
	}
	dmat4 rot = dmat4(cos_d, cos_e*sin_d, sin_e*sin_d, 0,
				-sin_d, cos_e*cos_d, sin_e*cos_d, 0,
				0, -sin_e, cos_e, 0,
				0,0,0,1);
	dmat4 inv_rot = dmat4(cos_d, -sin_d, 0, 0, 
				cos_e*sin_d, cos_e*cos_d, -sin_e, 0,
				sin_e*sin_d, sin_e*cos_d, cos_e, 0,
				0,0,0,1);
	r.position = dvec3(rot * dvec4(r.position,1));
	r.direction = dvec4(rot * r.direction);
	
	double y1 = (r.position[1]*r.position[1]+r.position[2]*r.position[2]-(r.position[2]-a1));
	y1 = y1*y1;
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] -= a1;
	}else{
	   r.weight = 0.0;
	}
	r.position = dvec3(inv_rot * dvec4(r.position,1));
	r.direction = dvec4(inv_rot * r.direction);
	return r;
}

// refraction function used for plane gratings
// normal is always the same (0,1,0) -> no trigonometric functions necessary
Ray refrac_plane(Ray r, dvec4 normal, double a){
	double eps1 = 0.0; //-atan(an_x/an_z) around z, chi
	double del1 = 0.0; // -asin(an_z); // -asin around x, psi
	
	double cos_d = 1.0;
	double sin_d = 0.0;
	double cos_e = 1.0;
	double sin_e = 0.0;
	double a1 = a*cos_d; // cos
	dmat4 rot = dmat4(cos_d, 	cos_e*sin_d, 	sin_e*sin_d, 	0,
				-sin_d, 		cos_e*cos_d, 	sin_e*cos_d, 	0,
				0, 				-sin_e, 		cos_e, 			0,
				0,				0,				0,				1);
	dmat4 inv_rot = dmat4(cos_d,  		-sin_d,			0, 		0, 
						cos_e*sin_d, 	cos_e*cos_d, 	-sin_e, 0,
						sin_e*sin_d, 	sin_e*cos_d, 	cos_e,	0,
						0,				0,				0,		1);
	r.position = dvec3(rot * dvec4(r.position,1));
	r.direction = dvec4(rot * r.direction);
	
	double y1 = r.direction[1]*r.direction[1] + r.direction[2]*r.direction[2] - (r.direction[2]-a1)*(r.direction[2]-a1);
	if (y1 > 0){
		y1 = sqrt(y1);
		r.direction[1] = y1;
		r.direction[2] = r.direction[2] - a1;
	}else{
	   r.weight = 0.0;
	}
	r.position = dvec3(inv_rot * dvec4(r.position,1));
	r.direction = dvec4(inv_rot * r.direction);
	return r;
}

/** not ready for testing yet
* calculates resulting ray for grating element
* transforms ray to object coordinate system, takes misalignment into account, traces the ray and transforms ray resulting of interaction with grating back to beam coordinates
* @param r				ray to trace
* @param q				quadric surface
*
* output: reflected Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight
*/
Ray tracePlaneGrating(Ray r, Quadric q) {
	r.position = dvec3(q.misalignment * (q.inTrans *  dvec4(r.position,1)) );
	r.direction = dvec4(q.misalignment * (q.inTrans * r.direction));
	
	dvec4 normal = intersectionPoint(r, q.anchorPoints, 1);
	r = refrac_plane(r, normal, 0.01239852);
	
	double xLength = q.anchorPoints[1][0]; // only 10 of the 16 anchorpoints are important for the intersection point function ("quad function"), since the matrix A is symmetric
	double zLength = q.anchorPoints[2][0]; // therefore we can use 6 values in the lower left part (without the diagonal) to transfer other values to the shader (eg dimensions of a mirror/grating), we use a_21,a_31 for xlength and zlength
	r.weight = wasteBox(r.position[0],r.position[2],xLength,zLength, r.weight);
	
	r.position = dvec3(q.outTrans * (q.inverseMisalignment * dvec4(r.position,1)));
	r.direction = q.outTrans * (q.inverseMisalignment * r.direction);
	return r;
}

/**
* calculates resulting ray for a mirror element
* transforms ray to object coordinate system, takes misalignment into account, traces the ray and transforms ray resulting of interaction with opt. element back to beam coordinates
* @param r				ray to trace
* @param q				quadric surface
*
* output: reflected Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight
*/
Ray traceMirror(Ray r, Quadric q) {
	r.position = dvec3(q.misalignment * (q.inTrans *  dvec4(r.position,1)) );
	r.direction = dvec4(q.misalignment * (q.inTrans * r.direction));
	
	dvec4 normal = intersectionPoint(r, q.anchorPoints, 1);
	r.direction = reflect(r.direction, normal);
	
	// will be changed, when width & heigth in "parameters"
	double xLength = q.anchorPoints[1][0]; // only 10 of the 16 anchorpoints are important for the intersection point function ("quad function"), since the matrix A is symmetric
	double zLength = q.anchorPoints[2][0]; // therefore we can use 6 values in the lower left part (without the diagonal) to transfer other values to the shader (eg dimensions of a mirror/grating), we use a_21,a_31 for xlength and zlength
	r.weight = wasteBox(r.position[0],r.position[2],xLength,zLength, r.weight);
	
	r.position = dvec3(q.outTrans * (q.inverseMisalignment * dvec4(r.position,1)));
	r.direction = q.outTrans * (q.inverseMisalignment * r.direction);
	return r;
}

/**
* OLD 
* transforms ray to object coordinate system, takes misalignment into account, traces the ray and transforms ray resulting of interaction with opt. element back to beam coordinates
* @param r				ray to trace
* @param q				quadric surface
*
* output: reflected Ray with intersection point as position, reflection as direction in beam coordinates and possibly modified weight
*/
Ray traceRay(Ray r, Quadric q) {
	r.position = dvec3(q.misalignment * (q.inTrans *  dvec4(r.position,1)) );
	r.direction = dvec4(q.misalignment * (q.inTrans * r.direction));
	
	dvec4 normal = intersectionPoint(r, q.anchorPoints, 1);
	double xLength = q.anchorPoints[1][0]; // only 10 of the 16 anchorpoints are important for the intersection point function ("quad function"), since the matrix A is symmetric
	double zLength = q.anchorPoints[2][0]; // therefore we can use 6 values in the lower left part (without the diagonal) to transfer other values to the shader (eg dimensions of a mirror/grating), we use a_21,a_31 for xlength and zlength
	//refl_r.weight = zLength;
	r.weight = wasteBox(r.position[0],r.position[2],xLength,zLength, r.weight);
	
	r.position = dvec3(q.outTrans * (q.inverseMisalignment * dvec4(r.position,1)));
	r.direction = q.outTrans * (q.inverseMisalignment * r.direction);
	return r;
}

void iterateQuadrics(){
	const int numberOfRays = rayData.length();
	const int numberOfQuadrics = quadricData.length()-1;
	double type;
	if(numberOfQuadrics <2){
		type = quadricData[numberOfQuadrics-1].anchorPoints[3][0];
		//only one quadric: store directly in output buffer
		// info if element is grating/mirror/... will later be stored in separate "parameter" dmat4
		if (type == 0) { // mirror
			outputData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], quadricData[numberOfQuadrics-1]);
		}else if(type == 1) { // plane grating
			outputData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], quadricData[numberOfQuadrics-1]);
		}else{ // undefined
			outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
		}

	}
	else{
		//at least 2 quadrics
		//for first quadric, read data from the input buffer RayData[] and write to the temporary storage temporaryRays[]
		//for last quadric, read data from temporary storage and write to output buffer
		//between read and write from/to temporary storage

		//quadrics between first and last
		for(int i=0; i<numberOfQuadrics-1; i++){
			type = quadricData[i].anchorPoints[3][0];
			//first quadric
			if (type == 0) { // mirror
				rayData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], quadricData[i]);
			}else if(type == 1){ // plane grating
				rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], quadricData[i]);	
			}else{ // undefined
				rayData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
			}
		}
		//last quadric
		type = quadricData[numberOfQuadrics-1].anchorPoints[3][0];
		if(type==0){ // mirror
			outputData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], quadricData[numberOfQuadrics-1]);
		}else if(type==1) { // plane grating
			outputData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], quadricData[numberOfQuadrics-1]);
		}else{
			outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
		}
	}

}
/*
void cameraPlaneIntersection(outputData, cameraPlane){	
	const int numberOfQuadrics = quadricData.length()
	Ray temporaryOutputVector;
	temporaryOutputVector = traceRay(outputData[uint(gl_GlobalInvocationID)], quadricData[numberOfQuadrics-1]);
	outputData[uint(gl_GlobalInvocationID)].position = temporaryOutputVector.position;
}
*/
void main(){
	iterateQuadrics();
	// outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
	// outputData[uint(gl_GlobalInvocationID)].position = rayData[uint(gl_GlobalInvocationID)].position; // starts at (0,20,-20)
	// outputData[uint(gl_GlobalInvocationID)].direction = dvec4(0.0, 0.0, 0.0, 0.0); // hits the surface in 45 degree angle at (0,0,0) -> the normal should be (0,-1,0)
	
}
